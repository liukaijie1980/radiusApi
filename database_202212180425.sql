--
-- Script was generated by Devart dbForge Studio 2020 for MySQL, Version 9.0.338.0
-- Product home page: http://www.devart.com/dbforge/mysql/studio
-- Script date 2022/12/18 4:25:07
-- Server version: 8.0.28
-- Client version: 4.1
--

-- 
-- Disable foreign keys
-- 
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;

-- 
-- Set SQL mode
-- 
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

-- 
-- Set character set the client will use to send SQL statements to the server
--
SET NAMES 'utf8';

--
-- Set default database
--
USE radius;

--
-- Drop table `admin`
--
DROP TABLE IF EXISTS admin;

--
-- Drop table `nas`
--
DROP TABLE IF EXISTS nas;

--
-- Drop table `sidebar_tree`
--
DROP TABLE IF EXISTS sidebar_tree;

--
-- Drop event `event_of_day`
--
DROP EVENT IF EXISTS event_of_day;

--
-- Drop trigger `radpostauth_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS radpostauth_BEFORE_INSERT;

--
-- Drop trigger `radpostauth_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS radpostauth_BEFORE_UPDATE;

--
-- Drop table `radpostauth`
--
DROP TABLE IF EXISTS radpostauth;

--
-- Drop procedure `proc_create_partition_day`
--
DROP PROCEDURE IF EXISTS proc_create_partition_day;

--
-- Drop event `event_of_month`
--
DROP EVENT IF EXISTS event_of_month;

--
-- Drop procedure `proc_drop_partition`
--
DROP PROCEDURE IF EXISTS proc_drop_partition;

--
-- Drop event `event_of_minute`
--
DROP EVENT IF EXISTS event_of_minute;

--
-- Drop trigger `offline_user_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS offline_user_BEFORE_INSERT;

--
-- Drop trigger `offline_user_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS offline_user_BEFORE_UPDATE;

--
-- Drop trigger `online_user_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS online_user_BEFORE_INSERT;

--
-- Drop trigger `online_user_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS online_user_BEFORE_UPDATE;

--
-- Drop table `online_user`
--
DROP TABLE IF EXISTS online_user;

--
-- Drop table `realm`
--
DROP TABLE IF EXISTS realm;

--
-- Drop table `offline_user`
--
DROP TABLE IF EXISTS offline_user;

--
-- Drop procedure `proc_create_partition_month`
--
DROP PROCEDURE IF EXISTS proc_create_partition_month;

--
-- Drop view `view_radcheck`
--
DROP VIEW IF EXISTS view_radcheck CASCADE;

--
-- Drop procedure `my_insert_radcheck`
--
DROP PROCEDURE IF EXISTS my_insert_radcheck;

--
-- Drop table `radcheck`
--
DROP TABLE IF EXISTS radcheck;

--
-- Drop view `view_radreply`
--
DROP VIEW IF EXISTS view_radreply CASCADE;

--
-- Drop table `account_info`
--
DROP TABLE IF EXISTS account_info;

--
-- Drop table `radreply`
--
DROP TABLE IF EXISTS radreply;

--
-- Drop function `get_radius_class_attr`
--
DROP FUNCTION IF EXISTS get_radius_class_attr;

--
-- Drop function `get_radius_hw_attr`
--
DROP FUNCTION IF EXISTS get_radius_hw_attr;

--
-- Drop function `get_radius_zte_attr`
--
DROP FUNCTION IF EXISTS get_radius_zte_attr;

--
-- Set default database
--
USE radius;

DELIMITER $$

--
-- Create function `get_radius_zte_attr`
--
CREATE DEFINER = 'root'@'%'
FUNCTION get_radius_zte_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN
  DECLARE ustr,
          dstr varchar(100);
  IF (dlimit = 0
    OR ulimit = 0) THEN
    RETURN NULL;
  END IF;
  SET ustr := HEX(ulimit);
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN
    SET ustr := 'FFFFFFFF';
  END IF;
  SET ustr := LPAD(ustr, 8, '0');
  SET dstr := HEX(dlimit);
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN
    SET dstr := 'FFFFFFFF';
  END IF;
  SET dstr := LPAD(dstr, 8, '0');
  RETURN CONCAT('0x00000F3E5906', dstr, '5306', ustr);

END
$$

--
-- Create function `get_radius_hw_attr`
--
CREATE DEFINER = 'root'@'%'
FUNCTION get_radius_hw_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN

  DECLARE ustr,
          dstr varchar(100);
  IF (dlimit = 0
    OR ulimit = 0) THEN
    RETURN NULL;
  END IF;

  SET ustr := HEX(ulimit * 1024);
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN
    SET ustr := 'FFFFFFFF';
  END IF;
  SET ustr := LPAD(ustr, 8, '0');

  SET dstr := HEX(dlimit * 1024);
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN
    SET dstr := 'FFFFFFFF';
  END IF;
  SET dstr := LPAD(dstr, 8, '0');

  RETURN CONCAT('0x000007DB0206', dstr, '0306', dstr, '0506', ustr, '0606', ustr);
END
$$

--
-- Create function `get_radius_class_attr`
--
CREATE DEFINER = 'root'@'%'
FUNCTION get_radius_class_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN
  #本函数输入上行速率，下行速率，转换为 radius client 接受的class 格式的字符串输出
  #若用Class属性携带CAR参数，长度最短为32位，且字符串中必须是0~9之间的数字，不能含有其它字符。将前32字节分成4个8字节
  DECLARE ustr,
          dstr varchar(100);

  SELECT
    CONCAT(ulimit * 1024, '') INTO ustr
  FROM dual;
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN
    #规定最大只能8位，超出无效，需要用厂家专用的26号radius属性进行调速
    RETURN NULL;
  END IF;
  SET ustr := LPAD(ustr, 8, '0');

  SELECT
    CONCAT(dlimit * 1024, '') INTO dstr
  FROM dual;
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN
    #规定最大只能8位，超出无效，需要用厂家专用的26号radius属性进行调速
    RETURN NULL;
  END IF;

  SET dstr := LPAD(dstr, 8, '0');

  #class 格式上行峰值速率，上行平均速率，下行峰值速率，下行平均速率
  RETURN CONCAT(ustr, ustr, dstr, dstr);
END
$$

DELIMITER ;

--
-- Create table `radreply`
--
CREATE TABLE radreply (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  attribute varchar(64) NOT NULL DEFAULT '',
  op char(2) NOT NULL DEFAULT ':=',
  value varchar(253) NOT NULL DEFAULT '',
  account_id varchar(36) NOT NULL,
  is_frozen tinyint NOT NULL DEFAULT 0,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 3,
AVG_ROW_LENGTH = 8192,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

--
-- Create index `username` on table `radreply`
--
ALTER TABLE radreply
ADD INDEX username (username (32));

--
-- Create table `account_info`
--
CREATE TABLE account_info (
  id varchar(36) NOT NULL,
  user_name varchar(45) NOT NULL COMMENT '该字段和realm的组合通过唯一约束保证不重复',
  realm varchar(45) NOT NULL DEFAULT '',
  user_password varchar(45) NOT NULL DEFAULT '',
  auth_mode int UNSIGNED ZEROFILL NOT NULL DEFAULT 0000000000,
  is_frozen tinyint NOT NULL DEFAULT 0,
  admin_name varchar(45) NOT NULL DEFAULT '',
  valid_date datetime DEFAULT CURRENT_TIMESTAMP,
  expire_date datetime DEFAULT NULL,
  modify_date datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '通过update触发器自动维护',
  simual_use_limit int NOT NULL DEFAULT 0,
  byte_remain bigint NOT NULL DEFAULT 0,
  second_remain bigint NOT NULL DEFAULT 0,
  max_session_timeout int NOT NULL DEFAULT 0,
  inbound_car int NOT NULL DEFAULT 0,
  outbound_car int NOT NULL DEFAULT 0,
  qos_profile varchar(45) NOT NULL DEFAULT '' COMMENT 'qos 模板，对应BRAS起的名字',
  update_interval int NOT NULL DEFAULT 0 COMMENT '计费报文间隔',
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 5461,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci,
COMMENT = '上网用户账号的属性表。方便ui展示和管理，最终要转换到radcheck和radreply的表让radius进程读取才起作用。';

--
-- Create index `id_UNIQUE` on table `account_info`
--
ALTER TABLE account_info
ADD UNIQUE INDEX id_UNIQUE (id) INVISIBLE;

--
-- Create index `user_unique` on table `account_info`
--
ALTER TABLE account_info
ADD UNIQUE INDEX user_unique (user_name, realm);

--
-- Create view `view_radreply`
--
CREATE
DEFINER = 'root'@'%'
VIEW view_radreply
AS
SELECT
  `radreply`.`id` AS `id`,
  CONCAT(`radreply`.`username`, `radreply`.`realm`) AS `UserName`,
  `radreply`.`attribute` AS `Attribute`,
  `radreply`.`value` AS `Value`,
  `radreply`.`op` AS `op`
FROM `radreply`
WHERE (`radreply`.`attribute` NOT IN ('Session-Timeout', 'Acct-Interim-Interval', 'Class'))
UNION ALL
SELECT
  '1000' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Session-Timeout' AS `Attribute`,
  `account_info`.`max_session_timeout` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE (`account_info`.`max_session_timeout` <> 0)
UNION ALL
SELECT
  '1001' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Acct-Interim-Interval' AS `Attribute`,
  `account_info`.`update_interval` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE (`account_info`.`update_interval` <> 0)
UNION ALL
SELECT
  '1002' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Class' AS `Attribute`,
  `GET_RADIUS_CLASS_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE (`GET_RADIUS_CLASS_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL)
UNION ALL
SELECT
  '1003' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_HW_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE (`GET_RADIUS_HW_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL)
UNION ALL
SELECT
  '1004' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_ZTE_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE (`GET_RADIUS_ZTE_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL);

--
-- Create table `radcheck`
--
CREATE TABLE radcheck (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  attribute varchar(64) NOT NULL DEFAULT '',
  op char(2) NOT NULL DEFAULT ':=',
  value varchar(253) NOT NULL DEFAULT '',
  account_id varchar(36) NOT NULL,
  is_frozen tinyint NOT NULL DEFAULT 0,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 24,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

--
-- Create index `ix_rcheck_username` on table `radcheck`
--
ALTER TABLE radcheck
ADD INDEX ix_rcheck_username (username);

DELIMITER $$

--
-- Create procedure `my_insert_radcheck`
--
CREATE DEFINER = 'root'@'%'
PROCEDURE my_insert_radcheck (IN cnt int)
BEGIN
  DECLARE n int DEFAULT 0;
loopname:
  LOOP
    INSERT INTO `radcheck` (`username`, `attribute`, `op`, `value`)
      VALUES (CONCAT('test_', n), 'User-Password', ':=', '1234');
    SET n = n + 1;
    IF n >= cnt THEN
      LEAVE loopname;
    END IF;
  END LOOP loopname;
END
$$

DELIMITER ;

--
-- Create view `view_radcheck`
--
CREATE
DEFINER = 'root'@'%'
VIEW view_radcheck
AS
SELECT
  `radcheck`.`id` AS `id`,
  CONCAT(`radcheck`.`username`, `radcheck`.`realm`) AS `UserName`,
  `radcheck`.`attribute` AS `Attribute`,
  `radcheck`.`value` AS `Value`,
  `radcheck`.`op` AS `op`
FROM `radcheck`
WHERE (`radcheck`.`attribute` NOT IN ('Cleartext-Password', 'Simultaneous-Use'))
UNION ALL
SELECT
  '1100' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Cleartext-Password' AS `Attribute`,
  `account_info`.`user_password` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE ((`account_info`.`is_frozen` = 0)
AND (((`account_info`.`valid_date` IS NOT NULL)
AND (`account_info`.`valid_date` < NOW()))
OR (`account_info`.`valid_date` IS NULL))
AND (((`account_info`.`expire_date` IS NOT NULL)
AND (`account_info`.`expire_date` > NOW()))
OR (`account_info`.`expire_date` IS NULL))
AND (`account_info`.`byte_remain` >= 0)
AND (`account_info`.`second_remain` >= 0))
UNION ALL
SELECT
  '1101' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Simultaneous-Use' AS `Attribute`,
  `account_info`.`simual_use_limit` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE (`account_info`.`simual_use_limit` > 0);

DELIMITER $$

--
-- Create procedure `proc_create_partition_month`
--
CREATE DEFINER = 'root'@'%'
PROCEDURE proc_create_partition_month (IN `tableName` varchar(128) CHARSET utf8,
IN `timeColName` varchar(128) CHARSET utf8)
BEGIN
  DECLARE p_id int;
  DECLARE nextDate date;
  DECLARE lastDate long;
  DECLARE p_name varchar(16);

  SELECT
    COUNT(partition_name) INTO p_id
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName;

  IF p_id = 0 THEN

    SELECT
      DATE_ADD(CURDATE() - DAY(CURDATE()) + 1, INTERVAL 1 MONTH) INTO nextDate
    FROM DUAL;

    SET p_name = DATE_FORMAT(CURDATE(), '%Y%m');
    SET @v_add = CONCAT('ALTER table ', tableName
    , ' PARTITION by range(TO_DAYS('
    , timeColName
    , '))(partition '
    , CONCAT('p', p_name)
    , ' values less than (TO_DAYS("'
    , nextDate, '")))');
  ELSE

    SELECT
      MAX(partition_description) des INTO lastDate
    FROM INFORMATION_SCHEMA.partitions
    WHERE TABLE_NAME = tableName;

    SELECT
      DATE_ADD(FROM_DAYS(lastDate), INTERVAL 1 MONTH) INTO nextDate
    FROM DUAL;

    SET p_name = DATE_FORMAT(FROM_DAYS(lastDate), '%Y%m');
    SET @v_add = CONCAT('alter table ', tableName
    , ' add partition (partition '
    , CONCAT('p', p_name)
    , ' values less than (TO_DAYS("'
    , nextDate, '")))');
  END IF;

  PREPARE stmt FROM @v_add;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;
END
$$

DELIMITER ;

--
-- Create table `offline_user`
--
CREATE TABLE offline_user (
  radacctid bigint NOT NULL AUTO_INCREMENT,
  acctsessionid varchar(64) NOT NULL DEFAULT '',
  acctuniqueid varchar(32) NOT NULL DEFAULT '',
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  nasipaddress varchar(15) NOT NULL DEFAULT '',
  nasportid varchar(120) DEFAULT NULL,
  nasporttype varchar(32) DEFAULT NULL,
  acctstarttime datetime DEFAULT NULL,
  acctupdatetime datetime DEFAULT NULL,
  acctstoptime datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  acctinterval int DEFAULT NULL,
  acctsessiontime int DEFAULT NULL,
  acctauthentic varchar(32) DEFAULT NULL,
  connectinfo_start varchar(128) DEFAULT NULL,
  connectinfo_stop varchar(128) DEFAULT NULL,
  acctinputoctets bigint DEFAULT NULL,
  acctoutputoctets bigint DEFAULT NULL,
  calledstationid varchar(50) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  acctterminatecause varchar(32) NOT NULL DEFAULT '',
  servicetype varchar(32) DEFAULT NULL,
  framedprotocol varchar(32) DEFAULT NULL,
  framedipaddress varchar(15) NOT NULL DEFAULT '',
  framedipv6address varchar(45) NOT NULL DEFAULT '',
  framedipv6prefix varchar(45) NOT NULL DEFAULT '',
  framedinterfaceid varchar(44) NOT NULL DEFAULT '',
  delegatedipv6prefix varchar(45) NOT NULL DEFAULT '',
  _class varchar(64) DEFAULT NULL,
  kickme int NOT NULL DEFAULT 0,
  PRIMARY KEY (radacctid, acctstoptime)
)
ENGINE = INNODB,
AUTO_INCREMENT = 1232336,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci
PARTITION BY RANGE (TO_DAYS(`acctstoptime`))
(
PARTITION p202212 VALUES LESS THAN (738886),
PARTITION p202301 VALUES LESS THAN (738917),
PARTITION p202302 VALUES LESS THAN (738945),
PARTITION p202303 VALUES LESS THAN (738976),
PARTITION p202304 VALUES LESS THAN (739006),
PARTITION p202305 VALUES LESS THAN (739037),
PARTITION p202306 VALUES LESS THAN (739067),
PARTITION p202307 VALUES LESS THAN (739098),
PARTITION p202308 VALUES LESS THAN (739129),
PARTITION p202309 VALUES LESS THAN (739159),
PARTITION p202310 VALUES LESS THAN (739190),
PARTITION p202311 VALUES LESS THAN (739220),
PARTITION max VALUES LESS THAN MAXVALUE
);

--
-- Create index `acctsessionid` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctsessionid (acctsessionid);

--
-- Create index `acctstarttime` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctstarttime (acctstarttime);

--
-- Create index `acctstoptime` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctstoptime (acctstoptime);

--
-- Create index `acctuniqueid` on table `offline_user`
--
ALTER TABLE offline_user
ADD UNIQUE INDEX acctuniqueid (acctuniqueid, acctstoptime);

--
-- Create index `callingstationid` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX callingstationid (callingstationid);

--
-- Create index `framedipaddress` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX framedipaddress (framedipaddress);

--
-- Create index `nasipaddress` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX nasipaddress (nasipaddress);

--
-- Create index `username` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX username (username);

--
-- Create table `realm`
--
CREATE TABLE realm (
  id varchar(36) NOT NULL,
  realm varchar(45) DEFAULT NULL,
  node_pid varchar(36) NOT NULL,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci,
COMMENT = '记录管理节点和域（realm）的对应关系。';

--
-- Create index `id_UNIQUE` on table `realm`
--
ALTER TABLE realm
ADD UNIQUE INDEX id_UNIQUE (id);

--
-- Create index `realm_UNIQUE` on table `realm`
--
ALTER TABLE realm
ADD UNIQUE INDEX realm_UNIQUE (realm);

--
-- Create table `online_user`
--
CREATE TABLE online_user (
  radacctid bigint NOT NULL AUTO_INCREMENT,
  acctsessionid varchar(64) NOT NULL DEFAULT '',
  acctuniqueid varchar(32) NOT NULL DEFAULT '',
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  nasipaddress varchar(15) NOT NULL DEFAULT '',
  nasportid varchar(120) DEFAULT NULL,
  nasporttype varchar(32) DEFAULT NULL,
  acctstarttime datetime DEFAULT NULL,
  acctupdatetime datetime DEFAULT NULL,
  acctstoptime datetime DEFAULT NULL,
  acctinterval int DEFAULT NULL,
  acctsessiontime int DEFAULT NULL,
  acctauthentic varchar(32) DEFAULT NULL,
  connectinfo_start varchar(128) DEFAULT NULL,
  connectinfo_stop varchar(128) DEFAULT NULL,
  acctinputoctets bigint DEFAULT NULL,
  acctoutputoctets bigint DEFAULT NULL,
  calledstationid varchar(50) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  acctterminatecause varchar(32) NOT NULL DEFAULT '',
  servicetype varchar(32) DEFAULT NULL,
  framedprotocol varchar(32) DEFAULT NULL,
  framedipaddress varchar(15) NOT NULL DEFAULT '',
  framedipv6address varchar(45) NOT NULL DEFAULT '',
  framedipv6prefix varchar(45) NOT NULL DEFAULT '',
  framedinterfaceid varchar(44) NOT NULL DEFAULT '',
  delegatedipv6prefix varchar(45) NOT NULL DEFAULT '',
  _class varchar(64) DEFAULT NULL,
  kickme int NOT NULL DEFAULT 0,
  PRIMARY KEY (radacctid)
)
ENGINE = INNODB,
AUTO_INCREMENT = 168,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

--
-- Create index `acctinterval` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctinterval (acctinterval);

--
-- Create index `acctsessionid` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctsessionid (acctsessionid);

--
-- Create index `acctsessiontime` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctsessiontime (acctsessiontime);

--
-- Create index `acctstarttime` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctstarttime (acctstarttime);

--
-- Create index `acctstoptime` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctstoptime (acctstoptime);

--
-- Create index `acctuniqueid` on table `online_user`
--
ALTER TABLE online_user
ADD UNIQUE INDEX acctuniqueid (acctuniqueid);

--
-- Create index `class` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX class (_class);

--
-- Create index `delegatedipv6prefix` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX delegatedipv6prefix (delegatedipv6prefix);

--
-- Create index `framedinterfaceid` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX framedinterfaceid (framedinterfaceid);

--
-- Create index `framedipaddress` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX framedipaddress (framedipaddress);

--
-- Create index `framedipv6address` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX framedipv6address (framedipv6address);

--
-- Create index `framedipv6prefix` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX framedipv6prefix (framedipv6prefix);

--
-- Create index `nasipaddress` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX nasipaddress (nasipaddress);

--
-- Create index `username` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX username (username);

DELIMITER $$

--
-- Create trigger `online_user_BEFORE_UPDATE`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER online_user_BEFORE_UPDATE
BEFORE UPDATE
ON online_user
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;



END
$$

--
-- Create trigger `online_user_BEFORE_INSERT`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER online_user_BEFORE_INSERT
BEFORE INSERT
ON online_user
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;

END
$$

--
-- Create trigger `offline_user_BEFORE_UPDATE`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER offline_user_BEFORE_UPDATE
BEFORE UPDATE
ON offline_user
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;

  IF new.acctsessiontime IS NOT NULL
    AND new.acctsessiontime != 0 THEN
    SET new.acctstarttime = DATE_SUB(new.acctstoptime, INTERVAL new.acctsessiontime SECOND);
    # 扣减剩余时长
    UPDATE account_info
    SET second_remain = (second_remain - new.acctsessiontime)
    WHERE user_name = new.username
    AND realm = NEW.realm
    AND second_remain > 0;
  ELSE
    #radius 没有传入acctsessiontime字段要从online_user表中取出对应的上线时间。  
    SET @starttime := new.acctstoptime;
    SELECT
      acctstarttime INTO @starttime
    FROM online_user
    WHERE acctsessionid = new.acctsessionid LIMIT 1;
    SET new.acctstarttime := @starttime;
    # 扣减剩余时长
    UPDATE account_info
    SET second_remain = (second_remain - (new.acctstoptime - new.acctstarttime))
    WHERE user_name = new.username
    AND realm = NEW.realm
    AND second_remain > 0;
  END IF;

  #扣减剩余流量
  UPDATE account_info
  SET byte_remain = (byte_remain - new.acctinputoctets - new.acctoutputoctets)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND byte_remain > 0;

  #该用户已经下线，所以从online_user表中删除对应表项
  DELETE
    FROM online_user
  WHERE acctsessionid = new.acctsessionid
    AND username = new.username
    AND realm = new.realm;
END
$$

--
-- Create trigger `offline_user_BEFORE_INSERT`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER offline_user_BEFORE_INSERT
BEFORE INSERT
ON offline_user
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;

  IF new.acctsessiontime IS NOT NULL
    AND new.acctsessiontime != 0 THEN
    SET new.acctstarttime = DATE_SUB(new.acctstoptime, INTERVAL new.acctsessiontime SECOND);
    # 扣减剩余时长
    UPDATE account_info
    SET second_remain = (second_remain - new.acctsessiontime)
    WHERE user_name = new.username
    AND realm = NEW.realm
    AND second_remain > 0;
  ELSE
    #radius 没有传入acctsessiontime字段要从online_user表中取出对应的上线时间。  
    SET @starttime := new.acctstoptime;
    SELECT
      acctstarttime INTO @starttime
    FROM online_user
    WHERE acctsessionid = new.acctsessionid LIMIT 1;
    SET new.acctstarttime := @starttime;
    # 扣减剩余时长
    UPDATE account_info
    SET second_remain = (second_remain - (new.acctstoptime - new.acctstarttime))
    WHERE user_name = new.username
    AND realm = NEW.realm
    AND second_remain > 0;
  END IF;

  #扣减剩余流量
  UPDATE account_info
  SET byte_remain = (byte_remain - new.acctinputoctets - new.acctoutputoctets)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND byte_remain > 0;

  #该用户已经下线，所以从online_user表中删除对应表项
  DELETE
    FROM online_user
  WHERE acctsessionid = new.acctsessionid
    AND username = new.username
    AND realm = new.realm;

END
$$

--
-- Create event `event_of_minute`
--
CREATE 
	DEFINER = 'root'@'%'
EVENT event_of_minute
	ON SCHEDULE EVERY '1' MINUTE
	STARTS '2022-12-16 07:35:48'
	DO 
BEGIN
#我们假设BRAS会定时发送计费更新报文，认为超过3600秒没有更新过在线记录的用户已经下线
UPDATE  radius.online_user SET acctstoptime=NOW() WHERE ABS(TIMESTAMPDIFF(SECOND, NOW(), acctupdatetime))>3600  ;
#我们希望将已经下线的记录’移动‘到offline_user表，因为目标表有触发器又会主动删除源表（online_user）中的对应记录，
#所以不能直接在用 insert into offline_user select from online_user, 而是需要建立一张临时表作为中转
#我们假设记录不多，所以临时表用了内存引擎，如果记录太大要改用其他引擎
CREATE  TEMPORARY  TABLE `temp_user` (
  `radacctid` bigint NOT NULL AUTO_INCREMENT,
  `acctsessionid` varchar(64) NOT NULL DEFAULT '',
  `acctuniqueid` varchar(32) NOT NULL DEFAULT '',
  `username` varchar(45) NOT NULL DEFAULT '',
  `realm` varchar(45) NOT NULL DEFAULT '',
  `nasidentifier` varchar(80) NOT NULL DEFAULT '',
  `nasipaddress` varchar(15) NOT NULL DEFAULT '',
  `nasportid` varchar(120) DEFAULT NULL,
  `nasporttype` varchar(32) DEFAULT NULL,
  `acctstarttime` datetime DEFAULT NULL,
  `acctupdatetime` datetime DEFAULT NULL,
  `acctstoptime` datetime DEFAULT NULL,
  `acctinterval` int DEFAULT NULL,
  `acctsessiontime` int DEFAULT NULL,
  `acctauthentic` varchar(32) DEFAULT NULL,
  `connectinfo_start` varchar(128) DEFAULT NULL,
  `connectinfo_stop` varchar(128) DEFAULT NULL,
  `acctinputoctets` bigint DEFAULT NULL,
  `acctoutputoctets` bigint DEFAULT NULL,
  `calledstationid` varchar(50) NOT NULL DEFAULT '',
  `callingstationid` varchar(50) NOT NULL DEFAULT '',
  `acctterminatecause` varchar(32) NOT NULL DEFAULT '',
  `servicetype` varchar(32) DEFAULT NULL,
  `framedprotocol` varchar(32) DEFAULT NULL,
  `framedipaddress` varchar(15) NOT NULL DEFAULT '',
  `framedipv6address` varchar(45) NOT NULL DEFAULT '',
  `framedipv6prefix` varchar(45) NOT NULL DEFAULT '',
  `framedinterfaceid` varchar(44) NOT NULL DEFAULT '',
  `delegatedipv6prefix` varchar(45) NOT NULL DEFAULT '',
  `_class` varchar(64) DEFAULT NULL,
   kickme int NOT NULL DEFAULT 0,
  PRIMARY KEY (`radacctid`),
  UNIQUE KEY `acctuniqueid` (`acctuniqueid`)

) ENGINE=memory  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

#先拷到临时表
INSERT INTO temp_user
SELECT * FROM online_user WHERE acctstoptime IS NOT NULL ;

#再拷到目标表，目标表的触发器会把源表的对应记录删除
INSERT INTO offline_user SELECT * FROM temp_user  ;
drop table temp_user;

END
$$

ALTER 
	DEFINER = 'root'@'%'
EVENT event_of_minute
	ENABLE
$$

--
-- Create procedure `proc_drop_partition`
--
CREATE DEFINER = 'root'@'%'
PROCEDURE proc_drop_partition (IN `tableName` varchar(128) CHARSET utf8)
BEGIN
  DECLARE p_id int;
  DECLARE p_name varchar(16);

  SELECT
    COUNT(partition_name) INTO p_id
  FROM INFORMATION_SCHEMA.PARTITIONS
  WHERE TABLE_NAME = tableName;

  IF p_id > 1 THEN

    SELECT
      PARTITION_NAME INTO p_name
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_NAME = tableName
    ORDER BY partition_ordinal_position LIMIT 1;

    IF p_name IS NOT NULL THEN
      SET @v_add = CONCAT('alter table ', tableName, ' drop partition ', p_name);
      PREPARE stmt FROM @v_add;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
    END IF;
  END IF;
END
$$

--
-- Create event `event_of_month`
--
CREATE 
	DEFINER = 'root'@'%'
EVENT event_of_month
	ON SCHEDULE EVERY '1' MONTH
	STARTS '2023-11-30 23:59:01'
	DO 
BEGIN

#因为我们从当日起已经在offline_user表中建了12个分区。所以首次启动时间需要设置在11个月29日之后

#为了防止没有及时创建分区而导致数据无法插入，保险起见预先多建了一个max分区，需要先删除该分区
alter table offline_user drop PARTITION max; 

#创建新分区
call proc_create_partition_month('offline_user','acctstoptime');
#重建max分区
ALTER TABLE offline_user ADD PARTITION (PARTITION max VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB);

#删除最旧的一个分区
call proc_drop_partition( 'offline_user');




END
$$

ALTER 
	DEFINER = 'root'@'%'
EVENT event_of_month
	ENABLE
$$

--
-- Create procedure `proc_create_partition_day`
--
CREATE DEFINER = 'root'@'%'
PROCEDURE proc_create_partition_day (IN `tableName` varchar(128) CHARSET utf8, IN `timeColName` varchar(128) CHARSET utf8)
BEGIN
  DECLARE p_id int;
  DECLARE nextDate date;
  DECLARE lastDate long;
  DECLARE p_name varchar(16);
  SELECT
    COUNT(partition_name) INTO p_id
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName;
  IF p_id = 0 THEN
    SELECT
      DATE_ADD(CURDATE(), INTERVAL 1 DAY) INTO nextDate
    FROM DUAL;
    SET p_name = DATE_FORMAT(CURDATE(), '%Y%m%d');
    SET @v_add = CONCAT('ALTER table ', tableName
    , ' PARTITION by range(TO_DAYS('
    , timeColName
    , '))(partition '
    , CONCAT('p', p_name)
    , ' values less than (TO_DAYS("'
    , nextDate, '")))');
  ELSE
    SELECT
      MAX(partition_description) des INTO lastDate
    FROM INFORMATION_SCHEMA.partitions
    WHERE TABLE_NAME = tableName;
    SELECT
      DATE_ADD(FROM_DAYS(lastDate), INTERVAL 1 DAY) INTO nextDate
    FROM DUAL;
    SET p_name = DATE_FORMAT(FROM_DAYS(lastDate), '%Y%m%d');
    SET @v_add = CONCAT('alter table ', tableName
    , ' add partition (partition '
    , CONCAT('p', p_name)
    , ' values less than (TO_DAYS("'
    , nextDate, '")))');
  END IF;

  PREPARE stmt FROM @v_add;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;
END
$$

DELIMITER ;

--
-- Create table `radpostauth`
--
CREATE TABLE radpostauth (
  id bigint NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  pass varchar(64) NOT NULL DEFAULT '',
  reply varchar(32) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  authdate datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  _class varchar(64) DEFAULT NULL,
  PRIMARY KEY (id, authdate)
)
ENGINE = INNODB,
AUTO_INCREMENT = 45,
AVG_ROW_LENGTH = 5698,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci,
COMMENT = '认证日志表，按天分区，保留7天'
PARTITION BY RANGE (TO_DAYS(`authdate`))
(
PARTITION p20221216 VALUES LESS THAN (738871),
PARTITION p20221217 VALUES LESS THAN (738872),
PARTITION p20221218 VALUES LESS THAN (738873),
PARTITION p20221219 VALUES LESS THAN (738874),
PARTITION p20221220 VALUES LESS THAN (738875),
PARTITION p20221221 VALUES LESS THAN (738876),
PARTITION p20221222 VALUES LESS THAN (738877),
PARTITION max VALUES LESS THAN MAXVALUE
);

--
-- Create index `username` on table `radpostauth`
--
ALTER TABLE radpostauth
ADD INDEX username (username);

DELIMITER $$

--
-- Create trigger `radpostauth_BEFORE_UPDATE`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER radpostauth_BEFORE_UPDATE
BEFORE UPDATE
ON radpostauth
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;
END
$$

--
-- Create trigger `radpostauth_BEFORE_INSERT`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER radpostauth_BEFORE_INSERT
BEFORE INSERT
ON radpostauth
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;
END
$$

--
-- Create event `event_of_day`
--
CREATE 
	DEFINER = 'root'@'%'
EVENT event_of_day
	ON SCHEDULE EVERY '1' DAY
	STARTS '2022-12-21 23:38:11'
	DO 
BEGIN
#因为我们从当日起已经在radpostauth表中建了7个分区。所以首次启动时间需要设置在6天23:59:50之后

#为了防止没有及时创建分区而导致数据无法插入，保险起见预先多建了一个max分区，需要先删除该分区
alter table radpostauth drop PARTITION max;
 
#在第6天尽头我们新建一个分区
call proc_create_partition_day('radpostauth','authdate');

#重建max分区
ALTER TABLE radpostauth ADD PARTITION (PARTITION max VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB);



#然后删除最早的一个分区
call proc_drop_partition( 'radpostauth');


END
$$

ALTER 
	DEFINER = 'root'@'%'
EVENT event_of_day
	ENABLE
$$

DELIMITER ;

--
-- Create table `sidebar_tree`
--
CREATE TABLE sidebar_tree (
  id varchar(36) NOT NULL,
  label varchar(45) DEFAULT NULL,
  pid varchar(36) DEFAULT NULL,
  type tinyint DEFAULT NULL,
  owner varchar(45) DEFAULT NULL,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 2048,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci,
COMMENT = '管理后台的左侧树控件节点集合';

--
-- Create index `id_UNIQUE` on table `sidebar_tree`
--
ALTER TABLE sidebar_tree
ADD UNIQUE INDEX id_UNIQUE (id);

--
-- Create table `nas`
--
CREATE TABLE nas (
  id int NOT NULL AUTO_INCREMENT,
  nasname varchar(128) NOT NULL,
  shortname varchar(32) DEFAULT NULL,
  type varchar(30) DEFAULT 'other',
  ports int DEFAULT NULL,
  secret varchar(60) NOT NULL DEFAULT 'secret',
  server varchar(64) DEFAULT NULL,
  community varchar(50) DEFAULT NULL,
  description varchar(200) DEFAULT 'RADIUS Client',
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 3,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci;

--
-- Create index `nasname` on table `nas`
--
ALTER TABLE nas
ADD INDEX nasname (nasname);

--
-- Create table `admin`
--
CREATE TABLE admin (
  name varchar(45) NOT NULL,
  password varchar(45) DEFAULT NULL,
  nodeid varchar(36) DEFAULT NULL,
  role varchar(45) DEFAULT NULL,
  phone varchar(45) DEFAULT NULL,
  email varchar(45) DEFAULT NULL,
  PRIMARY KEY (name)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 2048,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci,
COMMENT = '节点管理员列表';

--
-- Create index `name_UNIQUE` on table `admin`
--
ALTER TABLE admin
ADD UNIQUE INDEX name_UNIQUE (name);

-- 
-- Restore previous SQL mode
-- 
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;

-- 
-- Enable foreign keys
-- 
/*!40014 SET FOREIGN_KEY_CHECKS = @OLD_FOREIGN_KEY_CHECKS */;