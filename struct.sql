--
-- Script was generated by Devart dbForge Studio 2022 for MySQL, Version 9.1.21.0
-- Product home page: http://www.devart.com/dbforge/mysql/studio
-- Script date 2023/9/24 5:04:56
-- Server version: 10.6.5
-- Client version: 4.1
--

-- 
-- Disable foreign keys
-- 
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;

-- 
-- Set SQL mode
-- 
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

-- 
-- Set character set the client will use to send SQL statements to the server
--
SET NAMES 'utf8';

--
-- Set default database
--
USE radius;

--
-- Drop event `event_of_day`
--
DROP EVENT IF EXISTS event_of_day;

--
-- Drop event `event_of_month`
--
DROP EVENT IF EXISTS event_of_month;

--
-- Drop procedure `EnableAllEvents`
--
DROP PROCEDURE IF EXISTS EnableAllEvents;

--
-- Drop procedure `ManagePartitionsByDay`
--
DROP PROCEDURE IF EXISTS ManagePartitionsByDay;

--
-- Drop procedure `ManagePartitionsByMonth`
--
DROP PROCEDURE IF EXISTS ManagePartitionsByMonth;

--
-- Drop procedure `proc_create_partition_day`
--
DROP PROCEDURE IF EXISTS proc_create_partition_day;

--
-- Drop procedure `proc_create_partition_month`
--
DROP PROCEDURE IF EXISTS proc_create_partition_month;

--
-- Drop procedure `proc_drop_partition`
--
DROP PROCEDURE IF EXISTS proc_drop_partition;

--
-- Drop procedure `make_node_statistic`
--
DROP PROCEDURE IF EXISTS make_node_statistic;

--
-- Drop procedure `make_report`
--
DROP PROCEDURE IF EXISTS make_report;

--
-- Drop event `event_of_minute`
--
DROP EVENT IF EXISTS event_of_minute;

--
-- Drop trigger `offline_user_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS offline_user_BEFORE_INSERT;

--
-- Drop trigger `offline_user_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS offline_user_BEFORE_UPDATE;

--
-- Drop trigger `online_user_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS online_user_BEFORE_INSERT;

--
-- Drop trigger `online_user_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS online_user_BEFORE_UPDATE;

--
-- Drop table `online_user`
--
DROP TABLE IF EXISTS online_user;

--
-- Drop procedure `database_Prune`
--
DROP PROCEDURE IF EXISTS database_Prune;

--
-- Drop procedure `generate_account`
--
DROP PROCEDURE IF EXISTS generate_account;

--
-- Drop table `realm`
--
DROP TABLE IF EXISTS realm;

--
-- Drop table `offline_user`
--
DROP TABLE IF EXISTS offline_user;

--
-- Drop table `admin`
--
DROP TABLE IF EXISTS admin;

--
-- Drop function `get_coa_secret`
--
DROP FUNCTION IF EXISTS get_coa_secret;

--
-- Drop function `get_reversal`
--
DROP FUNCTION IF EXISTS get_reversal;

--
-- Drop table `nas`
--
DROP TABLE IF EXISTS nas;

--
-- Drop trigger `radpostauth_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS radpostauth_BEFORE_INSERT;

--
-- Drop trigger `radpostauth_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS radpostauth_BEFORE_UPDATE;

--
-- Drop table `radpostauth`
--
DROP TABLE IF EXISTS radpostauth;

--
-- Drop view `view_radcheck`
--
DROP VIEW IF EXISTS view_radcheck CASCADE;

--
-- Drop view `view_radreply`
--
DROP VIEW IF EXISTS view_radreply CASCADE;

--
-- Drop trigger `trigger_modify_date`
--
DROP TRIGGER IF EXISTS trigger_modify_date;

--
-- Drop table `account_info`
--
DROP TABLE IF EXISTS account_info;

--
-- Drop table `radcheck`
--
DROP TABLE IF EXISTS radcheck;

--
-- Drop table `radreply`
--
DROP TABLE IF EXISTS radreply;

--
-- Drop function `get_radius_class_attr`
--
DROP FUNCTION IF EXISTS get_radius_class_attr;

--
-- Drop function `get_radius_hw_attr`
--
DROP FUNCTION IF EXISTS get_radius_hw_attr;

--
-- Drop function `get_radius_zte_attr`
--
DROP FUNCTION IF EXISTS get_radius_zte_attr;

--
-- Drop procedure `make_folder_statistic`
--
DROP PROCEDURE IF EXISTS make_folder_statistic;

--
-- Drop table `sidebar_tree`
--
DROP TABLE IF EXISTS sidebar_tree;

--
-- Drop table `node_statistic`
--
DROP TABLE IF EXISTS node_statistic;

--
-- Set default database
--
USE radius;

--
-- Create table `node_statistic`
--
CREATE TABLE node_statistic (
  node_id varchar(36) NOT NULL,
  total_accounts int(10) UNSIGNED DEFAULT 0,
  online_accounts int(10) UNSIGNED DEFAULT 0,
  online_terminals int(10) UNSIGNED DEFAULT 0,
  PRIMARY KEY (node_id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 5461,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `node_id_UNIQUE` on table `node_statistic`
--
ALTER TABLE node_statistic
ADD UNIQUE INDEX node_id_UNIQUE (node_id);

--
-- Create table `sidebar_tree`
--
CREATE TABLE sidebar_tree (
  id varchar(36) NOT NULL,
  label varchar(45) DEFAULT NULL,
  pid varchar(36) DEFAULT NULL,
  type tinyint(4) DEFAULT NULL,
  owner varchar(45) DEFAULT NULL,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 1365,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '管理后台的左侧树控件节点集合';

--
-- Create index `id_UNIQUE` on table `sidebar_tree`
--
ALTER TABLE sidebar_tree
ADD UNIQUE INDEX id_UNIQUE (id);

DELIMITER $$

--
-- Create procedure `make_folder_statistic`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE make_folder_statistic (IN `_node_id` varchar(36) CHARSET utf8, IN `i` int, IN `j` int, IN `k` int)
BEGIN
  DECLARE _pid varchar(36) DEFAULT "";

  #设置存储过程允许的最大递归层数，不设置默认为0，会导致递归调用失败
  SET @@max_sp_recursion_depth = 10;

  #判断该节点是否存在父节点
  IF EXISTS (SELECT
        *
      FROM sidebar_tree
      WHERE id = _node_id) THEN

    #存在则将父节点提取出来放到变量_pid
    SELECT
      pid INTO _pid
    FROM sidebar_tree
    WHERE id = _node_id;
    -- select _node_id, _pid;

    #如果该父节点存在记录，则本节点不是根节点（根节点的父节点指针没有对应记录）
    IF EXISTS (SELECT
          *
        FROM sidebar_tree
        WHERE id = _pid) THEN

      #则将当前节点的各个分量分别加到父节点
      INSERT INTO node_statistic (node_id, total_accounts, online_accounts, online_terminals)
        VALUE (_pid, total_accounts + i, online_accounts + j, online_terminals + k)
      ON DUPLICATE KEY UPDATE total_accounts = total_accounts + i, online_accounts = online_accounts + j, online_terminals = online_terminals + k;

      #递归调用自己直到找到根节点
      CALL make_folder_statistic(_pid, i, j, k);
    END IF;
  END IF;

END
$$

--
-- Create function `get_radius_zte_attr`
--
CREATE
DEFINER = 'root'@'%'
FUNCTION get_radius_zte_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN
  DECLARE ustr,
          dstr varchar(100);
  IF (dlimit = 0
    OR ulimit = 0) THEN
    RETURN NULL;
  END IF;
  SET ustr := HEX(ulimit);
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN
    SET ustr := 'FFFFFFFF';
  END IF;
  SET ustr := LPAD(ustr, 8, '0');
  SET dstr := HEX(dlimit);
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN
    SET dstr := 'FFFFFFFF';
  END IF;
  SET dstr := LPAD(dstr, 8, '0');
  RETURN CONCAT('0x00000F3E5906', dstr, '5306', ustr);

END
$$

--
-- Create function `get_radius_hw_attr`
--
CREATE
DEFINER = 'root'@'%'
FUNCTION get_radius_hw_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN

  DECLARE ustr,
          dstr varchar(100);
  IF (dlimit = 0
    OR ulimit = 0) THEN
    RETURN NULL;
  END IF;

  SET ustr := HEX(ulimit * 1024);
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN
    SET ustr := 'FFFFFFFF';
  END IF;
  SET ustr := LPAD(ustr, 8, '0');

  SET dstr := HEX(dlimit * 1024);
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN
    SET dstr := 'FFFFFFFF';
  END IF;
  SET dstr := LPAD(dstr, 8, '0');

  RETURN CONCAT('0x000007DB0206', dstr, '0306', dstr, '0506', ustr, '0606', ustr);
END
$$

--
-- Create function `get_radius_class_attr`
--
CREATE
DEFINER = 'root'@'%'
FUNCTION get_radius_class_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN
  #本函数输入上行速率，下行速率，转换为 radius client 接受的class 格式的字符串输出
  #若用Class属性携带CAR参数，长度最短为32位，且字符串中必须是0~9之间的数字，不能含有其它字符。将前32字节分成4个8字节
  DECLARE ustr,
          dstr varchar(100);

  SELECT
    CONCAT(ulimit * 1024, '') INTO ustr
  FROM dual;
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN
    #规定最大只能8位，超出无效，需要用厂家专用的26号radius属性进行调速
    RETURN NULL;
  END IF;
  SET ustr := LPAD(ustr, 8, '0');

  SELECT
    CONCAT(dlimit * 1024, '') INTO dstr
  FROM dual;
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN
    #规定最大只能8位，超出无效，需要用厂家专用的26号radius属性进行调速
    RETURN NULL;
  END IF;

  SET dstr := LPAD(dstr, 8, '0');

  #class 格式上行峰值速率，上行平均速率，下行峰值速率，下行平均速率
  RETURN CONCAT(ustr, ustr, dstr, dstr);
END
$$

DELIMITER ;

--
-- Create table `radreply`
--
CREATE TABLE radreply (
  id int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  attribute varchar(64) NOT NULL DEFAULT '',
  op char(2) NOT NULL DEFAULT ':=',
  value varchar(253) NOT NULL DEFAULT '',
  account_id varchar(36) NOT NULL,
  is_frozen tinyint(4) NOT NULL DEFAULT 0,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 3,
AVG_ROW_LENGTH = 8192,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `username` on table `radreply`
--
ALTER TABLE radreply
ADD INDEX username (username (32));

--
-- Create table `radcheck`
--
CREATE TABLE radcheck (
  id int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  attribute varchar(64) NOT NULL DEFAULT '',
  op char(2) NOT NULL DEFAULT ':=',
  value varchar(253) NOT NULL DEFAULT '',
  account_id varchar(36) NOT NULL,
  is_frozen tinyint(4) NOT NULL DEFAULT 0,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 24,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `ix_rcheck_username` on table `radcheck`
--
ALTER TABLE radcheck
ADD INDEX ix_rcheck_username (username);

--
-- Create table `account_info`
--
CREATE TABLE account_info (
  id varchar(36) NOT NULL,
  user_name varchar(45) NOT NULL COMMENT '该字段和realm的组合通过唯一约束保证不重复',
  realm varchar(45) NOT NULL DEFAULT '',
  user_password varchar(45) NOT NULL DEFAULT '',
  auth_mode int(10) UNSIGNED ZEROFILL NOT NULL DEFAULT 0000000000,
  is_frozen tinyint(4) NOT NULL DEFAULT 0,
  admin_name varchar(45) NOT NULL DEFAULT '',
  valid_date datetime DEFAULT current_timestamp,
  expire_date datetime DEFAULT NULL,
  modify_date datetime NOT NULL DEFAULT current_timestamp COMMENT '通过update触发器自动维护',
  simual_use_limit int(11) NOT NULL DEFAULT 0,
  byte_remain bigint(20) NOT NULL DEFAULT 0,
  second_remain bigint(20) NOT NULL DEFAULT 0,
  max_session_timeout int(11) NOT NULL DEFAULT 0,
  inbound_car int(11) NOT NULL DEFAULT 0,
  outbound_car int(11) NOT NULL DEFAULT 0,
  qos_profile varchar(45) NOT NULL DEFAULT '' COMMENT 'qos 模板，对应BRAS起的名字',
  update_interval int(11) NOT NULL DEFAULT 0 COMMENT '计费报文间隔',
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 5461,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '上网用户账号的属性表。方便ui展示和管理，最终要转换到radcheck和radreply的表让radius进程读取才起作用。';

--
-- Create index `user_unique` on table `account_info`
--
ALTER TABLE account_info
ADD UNIQUE INDEX user_unique (user_name, realm);

DELIMITER $$

--
-- Create trigger `trigger_modify_date`
--
CREATE
DEFINER = 'service_user'@'%'
TRIGGER trigger_modify_date
BEFORE UPDATE
ON account_info
FOR EACH ROW
BEGIN


  SET new.modify_date = CURRENT_TIMESTAMP;

END
$$

DELIMITER ;

--
-- Create view `view_radreply`
--
CREATE
DEFINER = 'root'@'%'
VIEW view_radreply
AS
SELECT
  `radreply`.`id` AS `id`,
  CONCAT(`radreply`.`username`, `radreply`.`realm`) AS `UserName`,
  `radreply`.`attribute` AS `Attribute`,
  `radreply`.`value` AS `Value`,
  `radreply`.`op` AS `op`
FROM `radreply`
WHERE `radreply`.`attribute` NOT IN ('Session-Timeout', 'Acct-Interim-Interval', 'Class')
UNION ALL
SELECT
  '1000' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Session-Timeout' AS `Attribute`,
  `account_info`.`max_session_timeout` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE `account_info`.`max_session_timeout` <> 0
UNION ALL
SELECT
  '1001' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Acct-Interim-Interval' AS `Attribute`,
  `account_info`.`update_interval` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE `account_info`.`update_interval` <> 0
UNION ALL
SELECT
  '1002' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Class' AS `Attribute`,
  `GET_RADIUS_CLASS_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_CLASS_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1003' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_HW_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_HW_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1004' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_ZTE_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_ZTE_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1005' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Class' AS `Attribute`,
  `GET_RADIUS_CLASS_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_CLASS_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1006' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_HW_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_HW_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1007' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_ZTE_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_ZTE_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) IS NOT NULL;

--
-- Create view `view_radcheck`
--
CREATE
DEFINER = 'root'@'%'
VIEW view_radcheck
AS
SELECT
  `radcheck`.`id` AS `id`,
  CONCAT(`radcheck`.`username`, `radcheck`.`realm`) AS `UserName`,
  `radcheck`.`attribute` AS `Attribute`,
  `radcheck`.`value` AS `Value`,
  `radcheck`.`op` AS `op`
FROM `radcheck`
WHERE `radcheck`.`attribute` NOT IN ('Cleartext-Password', 'Simultaneous-Use')
UNION ALL
SELECT
  '1100' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Cleartext-Password' AS `Attribute`,
  `account_info`.`user_password` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE `account_info`.`is_frozen` = 0
AND (`account_info`.`valid_date` IS NOT NULL
AND `account_info`.`valid_date` < CURRENT_TIMESTAMP()
OR `account_info`.`valid_date` IS NULL)
AND (`account_info`.`expire_date` IS NOT NULL
AND `account_info`.`expire_date` > CURRENT_TIMESTAMP()
OR `account_info`.`expire_date` IS NULL)
AND `account_info`.`byte_remain` >= 0
AND `account_info`.`second_remain` >= 0
UNION ALL
SELECT
  '1101' AS `id`,
  CONCAT(`account_info`.`user_name`, `account_info`.`realm`) AS `UserName`,
  'Simultaneous-Use' AS `Attribute`,
  `account_info`.`simual_use_limit` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE `account_info`.`simual_use_limit` > 0;

--
-- Create table `radpostauth`
--
CREATE TABLE radpostauth (
  id bigint(20) NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  pass varchar(64) NOT NULL DEFAULT '',
  reply varchar(32) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  authdate datetime NOT NULL DEFAULT current_timestamp ON UPDATE CURRENT_TIMESTAMP,
  _class varchar(64) DEFAULT NULL,
  PRIMARY KEY (id, authdate)
)
ENGINE = INNODB,
AUTO_INCREMENT = 158212,
AVG_ROW_LENGTH = 57344,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '认证日志表，按天分区，保留7天'
PARTITION BY RANGE (TO_DAYS(`authdate`))
(
PARTITION p20230922 VALUES LESS THAN (739151),
PARTITION max VALUES LESS THAN MAXVALUE
);

--
-- Create index `username` on table `radpostauth`
--
ALTER TABLE radpostauth
ADD INDEX username (username);

DELIMITER $$

--
-- Create trigger `radpostauth_BEFORE_UPDATE`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER radpostauth_BEFORE_UPDATE
BEFORE UPDATE
ON radpostauth
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;
END
$$

--
-- Create trigger `radpostauth_BEFORE_INSERT`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER radpostauth_BEFORE_INSERT
BEFORE INSERT
ON radpostauth
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;
END
$$

DELIMITER ;

--
-- Create table `nas`
--
CREATE TABLE nas (
  id int(11) NOT NULL AUTO_INCREMENT,
  nasname varchar(128) NOT NULL DEFAULT '*',
  shortname varchar(32) DEFAULT 'any',
  type varchar(30) DEFAULT 'other',
  ports int(11) DEFAULT 0,
  secret varchar(60) NOT NULL DEFAULT '',
  coa varchar(60) NOT NULL,
  reversal tinyint(1) NOT NULL DEFAULT 0,
  server varchar(64) DEFAULT NULL,
  community varchar(50) DEFAULT NULL,
  description varchar(200) DEFAULT 'RADIUS Client',
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 104,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `nasname` on table `nas`
--
ALTER TABLE nas
ADD INDEX nasname (nasname);

DELIMITER $$

--
-- Create function `get_reversal`
--
CREATE
DEFINER = 'service_user'@'%'
FUNCTION get_reversal (nasip varchar(255))
RETURNS tinyint(1)
BEGIN

  DECLARE done int DEFAULT 0;
  DECLARE ip varchar(255);
  DECLARE net varchar(255);
  DECLARE mask int;
  DECLARE mask_offset int;
  DECLARE value_reversal tinyint(1);
  DECLARE is_reversal tinyint(1);

  DECLARE cur CURSOR FOR
  SELECT
    nasname,
    reversal
  FROM nas;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  CREATE TEMPORARY TABLE TempResults (
    max_mask int,
    reversal tinyint(1)
  );

  OPEN cur;
read_loop:
  LOOP
    FETCH cur INTO ip, value_reversal;
    IF done THEN
      LEAVE read_loop;
    END IF;

    IF ip = '*' THEN
      INSERT INTO TempResults (max_mask, reversal)
        VALUES (0, value_reversal);

    ELSEIF ip = nasip THEN
      INSERT INTO TempResults (max_mask, reversal)
        VALUES (32, value_reversal);

    ELSEIF INSTR(ip, '/') > 0 THEN
      SET net = SUBSTRING_INDEX (ip, '/', 1);
      SET mask = CAST(SUBSTRING_INDEX (ip, '/', -1) AS UNSIGNED);
      SET mask_offset = 32 - mask;
      IF (INET_ATON(nasip) >> mask_offset << mask_offset) = (INET_ATON(net) >> mask_offset << mask_offset) THEN

        INSERT INTO TempResults (max_mask, reversal)
          VALUES (mask, value_reversal);
      END IF;



    END IF;


  END LOOP;
  CLOSE cur;

  SELECT
    reversal INTO is_reversal
  FROM TempResults
  ORDER BY max_mask DESC LIMIT 1;

  DROP TEMPORARY TABLE IF EXISTS TempResults;
  RETURN is_reversal;


END
$$

--
-- Create function `get_coa_secret`
--
CREATE
DEFINER = 'service_user'@'%'
FUNCTION get_coa_secret (nasip varchar(255))
RETURNS varchar(255) CHARSET utf8mb4
BEGIN

  DECLARE done int DEFAULT 0;
  DECLARE ip varchar(255);
  DECLARE net varchar(255);
  DECLARE mask int;
  DECLARE mask_offset int;

  DECLARE coa_secret varchar(255);

  DECLARE cur CURSOR FOR
  SELECT
    nasname,
    coa
  FROM nas;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  CREATE TEMPORARY TABLE TempResults (
    max_mask int,
    coa varchar(255)
  );

  OPEN cur;
read_loop:
  LOOP
    FETCH cur INTO ip, coa_secret;
    IF done THEN
      LEAVE read_loop;
    END IF;

    IF ip = '*' THEN
      INSERT INTO TempResults (max_mask, coa)
        VALUES (0, coa_secret);

    ELSEIF ip = nasip THEN
      INSERT INTO TempResults (max_mask, coa)
        VALUES (32, coa_secret);

    ELSEIF INSTR(ip, '/') > 0 THEN
      SET net = SUBSTRING_INDEX (ip, '/', 1);
      SET mask = CAST(SUBSTRING_INDEX (ip, '/', -1) AS UNSIGNED);
      SET mask_offset = 32 - mask;
      IF (INET_ATON(nasip) >> mask_offset << mask_offset) = (INET_ATON(net) >> mask_offset << mask_offset) THEN

        INSERT INTO TempResults (max_mask, coa)
          VALUES (mask, coa_secret);
      END IF;



    END IF;


  END LOOP;
  CLOSE cur;

  SELECT
    coa INTO coa_secret
  FROM TempResults
  ORDER BY max_mask DESC LIMIT 1;

  DROP TEMPORARY TABLE IF EXISTS TempResults;
  RETURN coa_secret;


END
$$

DELIMITER ;

--
-- Create table `admin`
--
CREATE TABLE admin (
  name varchar(45) NOT NULL,
  password varchar(45) DEFAULT NULL,
  nodeid varchar(36) DEFAULT NULL,
  role varchar(45) DEFAULT NULL,
  phone varchar(45) DEFAULT NULL,
  email varchar(45) DEFAULT NULL,
  PRIMARY KEY (name)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 1820,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '节点管理员列表';

--
-- Create index `name_UNIQUE` on table `admin`
--
ALTER TABLE admin
ADD UNIQUE INDEX name_UNIQUE (name);

--
-- Create table `offline_user`
--
CREATE TABLE offline_user (
  radacctid bigint(20) NOT NULL AUTO_INCREMENT,
  acctsessionid varchar(64) NOT NULL DEFAULT '',
  acctuniqueid varchar(32) NOT NULL DEFAULT '',
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  nasipaddress varchar(15) NOT NULL DEFAULT '',
  nasportid varchar(120) DEFAULT NULL,
  nasporttype varchar(32) DEFAULT NULL,
  acctstarttime datetime DEFAULT NULL,
  acctupdatetime datetime DEFAULT NULL,
  acctstoptime datetime NOT NULL DEFAULT current_timestamp,
  acctinterval int(11) DEFAULT NULL,
  acctsessiontime int(11) DEFAULT NULL,
  acctauthentic varchar(32) DEFAULT NULL,
  connectinfo_start varchar(128) DEFAULT NULL,
  connectinfo_stop varchar(128) DEFAULT NULL,
  acctinputoctets bigint(20) DEFAULT NULL,
  acctoutputoctets bigint(20) DEFAULT NULL,
  calledstationid varchar(50) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  acctterminatecause varchar(32) NOT NULL DEFAULT '',
  servicetype varchar(32) DEFAULT NULL,
  framedprotocol varchar(32) DEFAULT NULL,
  framedipaddress varchar(15) NOT NULL DEFAULT '',
  framedipv6address varchar(45) NOT NULL DEFAULT '',
  framedipv6prefix varchar(45) NOT NULL DEFAULT '',
  framedinterfaceid varchar(44) NOT NULL DEFAULT '',
  delegatedipv6prefix varchar(45) NOT NULL DEFAULT '',
  _class varchar(64) DEFAULT NULL,
  kickme int(11) NOT NULL DEFAULT 0,
  PRIMARY KEY (radacctid, acctstoptime)
)
ENGINE = INNODB,
AUTO_INCREMENT = 2675943,
AVG_ROW_LENGTH = 2184,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci
PARTITION BY RANGE (TO_DAYS(`acctstoptime`))
(
PARTITION p202309 VALUES LESS THAN (24286),
PARTITION max VALUES LESS THAN MAXVALUE
);

--
-- Create index `acctuniqueid` on table `offline_user`
--
ALTER TABLE offline_user
ADD UNIQUE INDEX acctuniqueid (acctuniqueid, acctstoptime);

--
-- Create index `acctsessionid` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctsessionid (acctsessionid);

--
-- Create index `acctstarttime` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctstarttime (acctstarttime);

--
-- Create index `acctstoptime` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctstoptime (acctstoptime);

--
-- Create index `callingstationid` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX callingstationid (callingstationid);

--
-- Create index `framedipaddress` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX framedipaddress (framedipaddress);

--
-- Create index `nasipaddress` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX nasipaddress (nasipaddress);

--
-- Create index `realm` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX realm (realm);

--
-- Create table `realm`
--
CREATE TABLE realm (
  id varchar(36) NOT NULL,
  realm varchar(45) DEFAULT NULL,
  node_id varchar(36) NOT NULL,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '记录sidebar_tree的node_id和域（realm）的对应关系。';

--
-- Create index `id_UNIQUE` on table `realm`
--
ALTER TABLE realm
ADD UNIQUE INDEX id_UNIQUE (id);

--
-- Create index `realm_UNIQUE` on table `realm`
--
ALTER TABLE realm
ADD UNIQUE INDEX realm_UNIQUE (realm);

DELIMITER $$

--
-- Create procedure `generate_account`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE generate_account (IN p_from int, IN p_to int)
BEGIN
  DECLARE current_val int DEFAULT p_from;
loopname:
  LOOP
    INSERT INTO radius.account_info (id, user_name, realm, user_password, auth_mode, is_frozen, admin_name, valid_date, expire_date, modify_date, simual_use_limit, byte_remain, second_remain, max_session_timeout, inbound_car, outbound_car, qos_profile, update_interval)
      VALUES (CONCAT('test_', current_val), current_val, '@kdlk', '00000000', 0, 0, 'admin', '2023-08-01 14:13:29', NULL, '2023-08-01 14:13:29', 1, 0, 0, 0, 256000, 512000, '', 900);
    SET current_val = current_val + 1;
    IF current_val > p_to THEN
      LEAVE loopname;
    END IF;
  END LOOP loopname;
END
$$

--
-- Create procedure `database_Prune`
--
CREATE
DEFINER = 'service_user'@'%'
PROCEDURE database_Prune ()
BEGIN

  DELETE
    FROM realm
  WHERE node_id NOT IN (SELECT
        id
      FROM sidebar_tree);

  DELETE
    FROM admin
  WHERE nodeid NOT IN (SELECT
        id
      FROM sidebar_tree);

  DELETE
    FROM offline_user
  WHERE realm NOT IN (SELECT
        realm
      FROM realm);


  DELETE
    FROM radpostauth
  WHERE realm NOT IN (SELECT
        realm
      FROM realm);
END
$$

DELIMITER ;

--
-- Create table `online_user`
--
CREATE TABLE online_user (
  radacctid bigint(20) NOT NULL AUTO_INCREMENT,
  acctsessionid varchar(64) NOT NULL DEFAULT '',
  acctuniqueid varchar(32) NOT NULL DEFAULT '',
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  nasipaddress varchar(15) NOT NULL DEFAULT '',
  nasportid varchar(120) DEFAULT NULL,
  nasporttype varchar(32) DEFAULT NULL,
  acctstarttime datetime DEFAULT NULL,
  acctupdatetime datetime NOT NULL DEFAULT current_timestamp,
  acctstoptime datetime DEFAULT NULL,
  acctinterval int(11) DEFAULT NULL,
  acctsessiontime int(11) DEFAULT NULL,
  acctauthentic varchar(32) DEFAULT NULL,
  connectinfo_start varchar(128) DEFAULT NULL,
  connectinfo_stop varchar(128) DEFAULT NULL,
  acctinputoctets bigint(20) DEFAULT NULL,
  acctoutputoctets bigint(20) DEFAULT NULL,
  calledstationid varchar(50) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  acctterminatecause varchar(32) NOT NULL DEFAULT '',
  servicetype varchar(32) DEFAULT NULL,
  framedprotocol varchar(32) DEFAULT NULL,
  framedipaddress varchar(15) NOT NULL DEFAULT '',
  framedipv6address varchar(45) NOT NULL DEFAULT '',
  framedipv6prefix varchar(45) NOT NULL DEFAULT '',
  framedinterfaceid varchar(44) NOT NULL DEFAULT '',
  delegatedipv6prefix varchar(45) NOT NULL DEFAULT '',
  _class varchar(64) DEFAULT NULL,
  kickme int(11) NOT NULL DEFAULT 0,
  PRIMARY KEY (radacctid)
)
ENGINE = INNODB,
AUTO_INCREMENT = 2675943,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `acctuniqueid` on table `online_user`
--
ALTER TABLE online_user
ADD UNIQUE INDEX acctuniqueid (acctuniqueid);

--
-- Create index `acctsessionid` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctsessionid (acctsessionid);

--
-- Create index `acctstarttime` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctstarttime (acctstarttime);

--
-- Create index `acctstoptime` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctstoptime (acctstoptime);

--
-- Create index `callingstationid` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX callingstationid (callingstationid);

--
-- Create index `framedipaddress` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX framedipaddress (framedipaddress);

--
-- Create index `framedipv6address` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX framedipv6address (framedipv6address);

--
-- Create index `nasipaddress` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX nasipaddress (nasipaddress);

--
-- Create index `username` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX username (username);

DELIMITER $$

--
-- Create trigger `online_user_BEFORE_UPDATE`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER online_user_BEFORE_UPDATE
BEFORE UPDATE
ON online_user
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;

  #为时间统一，不采信radius的时间而采用数据库的时间

  SET new.acctupdatetime = NOW();


END
$$

--
-- Create trigger `online_user_BEFORE_INSERT`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER online_user_BEFORE_INSERT
BEFORE INSERT
ON online_user
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;

  #为时间统一，不采信radius的时间而采用数据库的时间
  SET new.acctstarttime = NOW();
  SET new.acctupdatetime = NOW();

END
$$

--
-- Create trigger `offline_user_BEFORE_UPDATE`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER offline_user_BEFORE_UPDATE
BEFORE UPDATE
ON offline_user
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;

  #为时间统一，不采信radius进程的时间。
  SET new.acctstoptime = NOW();

  IF new.acctsessiontime IS NOT NULL
    AND new.acctsessiontime != 0 THEN
    SET new.acctstarttime = DATE_SUB(new.acctstoptime, INTERVAL new.acctsessiontime SECOND);
  ELSE
    #radius 没有传入acctsessiontime字段要从online_user表中取出对应的上线时间。  
    SET @starttime := new.acctstoptime;
    SELECT
      acctstarttime INTO @starttime
    FROM online_user
    WHERE acctsessionid = new.acctsessionid LIMIT 1;
    SET new.acctstarttime := @starttime;
    #注意datetime类型不能直接相减获得时间差,必须使用TIMESTAMPDIFF函数
    SET new.acctsessiontime = ABS(TIMESTAMPDIFF(SECOND, new.acctstarttime, new.acctstoptime));
  END IF;

  # 扣减剩余时长
  UPDATE account_info
  SET second_remain = (second_remain - new.acctsessiontime)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND second_remain > 0;

  #扣减剩余流量
  UPDATE account_info
  SET byte_remain = (byte_remain - new.acctinputoctets - new.acctoutputoctets)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND byte_remain > 0;

  #该用户已经下线，所以从online_user表中删除对应表项
  DELETE
    FROM online_user
  WHERE acctsessionid = new.acctsessionid
    AND username = new.username
    AND realm = new.realm;
END
$$

--
-- Create trigger `offline_user_BEFORE_INSERT`
--
CREATE
DEFINER = 'root'@'%'
TRIGGER offline_user_BEFORE_INSERT
BEFORE INSERT
ON offline_user
FOR EACH ROW
BEGIN
  #将radius进程传入的原始username，如格式为abc@realm 则改为 abc 存入 username, @realm 存入realm 字段
  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;
  #为时间统一，不采信radius进程的时间。
  SET new.acctstoptime = NOW();

  IF new.acctsessiontime IS NOT NULL
    AND new.acctsessiontime != 0 THEN
    SET new.acctstarttime = DATE_SUB(new.acctstoptime, INTERVAL new.acctsessiontime SECOND);
  ELSE
    #radius 没有传入acctsessiontime字段要从online_user表中取出对应的上线时间。  
    SET @starttime := new.acctstoptime;
    SELECT
      acctstarttime INTO @starttime
    FROM online_user
    WHERE acctsessionid = new.acctsessionid LIMIT 1;
    SET new.acctstarttime := @starttime;
    #注意datetime类型不能直接相减获得时间差,必须使用TIMESTAMPDIFF函数
    SET new.acctsessiontime = ABS(TIMESTAMPDIFF(SECOND, new.acctstarttime, new.acctstoptime));
  END IF;

  # 扣减剩余时长
  UPDATE account_info
  SET second_remain = (second_remain - new.acctsessiontime)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND second_remain > 0;

  #扣减剩余流量
  UPDATE account_info
  SET byte_remain = (byte_remain - new.acctinputoctets - new.acctoutputoctets)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND byte_remain > 0;

  #该用户已经下线，所以从online_user表中删除对应表项
  DELETE
    FROM online_user
  WHERE acctsessionid = new.acctsessionid
    AND username = new.username
    AND realm = new.realm;

END
$$

--
-- Create event `event_of_minute`
--
CREATE 
	DEFINER = 'service_user'@'%'
EVENT event_of_minute
	ON SCHEDULE EVERY '1' MINUTE
	STARTS '2023-09-20 18:38:45'
	DO 
BEGIN
#我们假设BRAS会定时发送计费更新报文，认为超过3600秒没有更新过在线记录的用户已经下线
UPDATE  radius.online_user SET acctstoptime=NOW() WHERE ABS(TIMESTAMPDIFF(SECOND, NOW(), acctupdatetime))>3600 AND acctstoptime IS NULL ;
#我们希望将已经下线的记录’移动‘到offline_user表，因为目标表有触发器又会主动删除源表（online_user）中的对应记录，
#所以不能直接在用 insert into offline_user select from online_user, 而是需要建立一张临时表作为中转
#我们假设记录不多，所以临时表用了内存引擎，如果记录太大要改用其他引擎
CREATE  TEMPORARY  TABLE `temp_user` (
  `radacctid` bigint NOT NULL AUTO_INCREMENT,
  `acctsessionid` varchar(64) NOT NULL DEFAULT '',
  `acctuniqueid` varchar(32) NOT NULL DEFAULT '',
  `username` varchar(45) NOT NULL DEFAULT '',
  `realm` varchar(45) NOT NULL DEFAULT '',
  `nasidentifier` varchar(80) NOT NULL DEFAULT '',
  `nasipaddress` varchar(15) NOT NULL DEFAULT '',
  `nasportid` varchar(120) DEFAULT NULL,
  `nasporttype` varchar(32) DEFAULT NULL,
  `acctstarttime` datetime DEFAULT NULL,
  `acctupdatetime` datetime DEFAULT NULL,
  `acctstoptime` datetime DEFAULT NULL,
  `acctinterval` int DEFAULT NULL,
  `acctsessiontime` int DEFAULT NULL,
  `acctauthentic` varchar(32) DEFAULT NULL,
  `connectinfo_start` varchar(128) DEFAULT NULL,
  `connectinfo_stop` varchar(128) DEFAULT NULL,
  `acctinputoctets` bigint DEFAULT NULL,
  `acctoutputoctets` bigint DEFAULT NULL,
  `calledstationid` varchar(50) NOT NULL DEFAULT '',
  `callingstationid` varchar(50) NOT NULL DEFAULT '',
  `acctterminatecause` varchar(32) NOT NULL DEFAULT '',
  `servicetype` varchar(32) DEFAULT NULL,
  `framedprotocol` varchar(32) DEFAULT NULL,
  `framedipaddress` varchar(15) NOT NULL DEFAULT '',
  `framedipv6address` varchar(45) NOT NULL DEFAULT '',
  `framedipv6prefix` varchar(45) NOT NULL DEFAULT '',
  `framedinterfaceid` varchar(44) NOT NULL DEFAULT '',
  `delegatedipv6prefix` varchar(45) NOT NULL DEFAULT '',
  `_class` varchar(64) DEFAULT NULL,
   kickme int NOT NULL DEFAULT 0,
  PRIMARY KEY (`radacctid`),
  UNIQUE KEY `acctuniqueid` (`acctuniqueid`)

) ENGINE=memory  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

#先拷到临时表
INSERT INTO temp_user
SELECT * FROM online_user WHERE acctstoptime IS NOT NULL ;

#再拷到目标表，目标表的触发器会把源表的对应记录删除
INSERT INTO offline_user SELECT * FROM temp_user  ;
drop table temp_user;

#清理ui上由于删除树节点而被破坏外键关联的元素
DELETE FROM realm  WHERE node_id NOT IN (SELECT id FROM sidebar_tree  );

DELETE FROM admin WHERE nodeid NOT IN (SELECT id FROM sidebar_tree  );
COMMIT;



END
$$

ALTER 
	DEFINER = 'service_user'@'%'
EVENT event_of_minute
	ENABLE
$$

--
-- Create procedure `make_report`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE make_report ()
BEGIN
  DECLARE acct1 int;
  DECLARE acct2 int;
  DECLARE acct int;
  DECLARE auth int;



  #10分钟内处理的计费报文
  SELECT
    COUNT(*) INTO acct1
  FROM offline_user
  WHERE acctstoptime > NOW() - INTERVAL 10 MINUTE;
  SELECT
    COUNT(*) INTO acct2
  FROM online_user
  WHERE acctupdatetime > NOW() - INTERVAL 10 MINUTE;
  SET acct = acct1 + acct2;

  #10分钟内处理的认证报文
  SELECT
    COUNT(*) INTO auth
  FROM radpostauth
  WHERE authdate > NOW() - INTERVAL 10 MINUTE;

  SELECT
    acct AS acct,
    auth AS auth;
#SELECT SUM(`acctinputoctets`+`acctoutputoctets`) FROM offline_user ;
#SELECT SUM(`acctinputoctets`+`acctoutputoctets`) FROM online_user ; 
#SELECT SUM(`acctsessiontime`) FROM offline_user;
#SELECT SUM(`acctsessiontime`) FROM online_user;

END
$$

--
-- Create procedure `make_node_statistic`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE make_node_statistic ()
BEGIN
  #1、通过两个嵌套游标，统计sidebar_tree表里面leaf节点里面包含的 总账号数，在线账号数，在线终端数,
  #并将统计结果储存在node_statistic表中。

  DECLARE i integer DEFAULT 0;
  DECLARE j integer DEFAULT 0;
  DECLARE k integer DEFAULT 0;

  #用于停止循环的开关变量（内外层循环公用）
  DECLARE v_finished integer DEFAULT 0;

  #存放游标遍历到的节点id
  DECLARE _node_id varchar(36) DEFAULT "";

  DECLARE _pid varchar(36) DEFAULT "";

  #存放游标遍历到的reaml
  DECLARE _realm varchar(45) DEFAULT "";

  -- declare cursor for node_id
  DECLARE leaf_cursor CURSOR FOR
  SELECT
    id
  FROM sidebar_tree
  WHERE type = 0;

  -- declare cursor for realm
  DECLARE realm_cursor CURSOR FOR
  SELECT
    realm
  FROM realm
  WHERE node_id = _node_id;

  -- declare cursor for leaf_id
  DECLARE leaf_statistic_cursor CURSOR FOR
  SELECT
    node_id
  FROM node_statistic
    INNER JOIN sidebar_tree
      ON node_statistic.node_id = sidebar_tree.id
  WHERE type = 0;

  -- declare NOT FOUND handler
  -- it is use for both inner and outer loop
  DECLARE CONTINUE HANDLER
  FOR NOT FOUND SET v_finished = 1;

  DELETE
    FROM node_statistic;
  OPEN leaf_cursor;
#外层循环取得树节点的id
get_id:
  LOOP
    FETCH leaf_cursor INTO _node_id;
    IF v_finished = 1 THEN
      LEAVE get_id;
    END IF;
    -- select _node_id;

    OPEN realm_cursor;
  #内层循环取得节点对应的realm值
  get_realm:
    LOOP
      FETCH realm_cursor INTO _realm;
      IF v_finished = 1 THEN
        LEAVE get_realm;
      END IF;
      -- SET realm_list = CONCAT(_realm,";",realm_list);
      -- select  realm_list ;
      SELECT
        COUNT(*) INTO i
      FROM account_info
      WHERE realm = _realm;
      SELECT
        COUNT(DISTINCT (username)) INTO j
      FROM online_user
      WHERE realm = _realm
      AND acctstoptime IS NULL;
      SELECT
        COUNT(DISTINCT (callingstationid)) INTO k
      FROM online_user
      WHERE realm = _realm
      AND acctstoptime IS NULL;

      #插入或更新到node_statistic表
      INSERT INTO node_statistic (node_id, total_accounts, online_accounts, online_terminals)
        VALUE (_node_id, total_accounts + i, online_accounts + j, online_terminals + k)
      ON DUPLICATE KEY UPDATE total_accounts = total_accounts + i, online_accounts = online_accounts + j, online_terminals = online_terminals + k;
    END LOOP get_realm;
    CLOSE realm_cursor;
    #内层循环结束，清除循环结束标志，以免影响外层循环
    SET v_finished = 0;
  END LOOP get_id;
  CLOSE leaf_cursor;
  SET v_finished = 0;

  #2、至此，表node_statistic里面记录了每个叶子节点的数据
  #从这些叶子节点的数据出发，通过调用递归存储过程，一直找到根folder节点，
  # 并在过程中将上面叶子节点的数据汇总到经过的每个folder节点中。
  OPEN leaf_statistic_cursor;
get_leaf_id:
  LOOP
    FETCH leaf_statistic_cursor INTO _node_id;
    IF v_finished = 1 THEN
      LEAVE get_leaf_id;
    END IF;
    SELECT
      total_accounts INTO i
    FROM node_statistic
    WHERE node_id = _node_id;
    SELECT
      online_accounts INTO j
    FROM node_statistic
    WHERE node_id = _node_id;
    SELECT
      online_terminals INTO k
    FROM node_statistic
    WHERE node_id = _node_id;

    #这里将数据交给 这个存储过程 ，该存储过程会递归直到找到根folder节点
    CALL make_folder_statistic(_node_id, i, j, k);
  -- LEAVE get_leaf_id;

  END LOOP get_leaf_id;
  CLOSE leaf_statistic_cursor;




END
$$

--
-- Create procedure `proc_drop_partition`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE proc_drop_partition (IN `tableName` varchar(128) CHARSET utf8, IN `reservePartition` int)
BEGIN
  DECLARE p_id int;
  DECLARE p_name varchar(16);

  SELECT
    COUNT(partition_name) INTO p_id
  FROM INFORMATION_SCHEMA.PARTITIONS
  WHERE TABLE_NAME = tableName;

  IF p_id > reservePartition THEN

    SELECT
      PARTITION_NAME INTO p_name
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_NAME = tableName
    ORDER BY partition_ordinal_position ASC LIMIT 1;

    IF p_name IS NOT NULL THEN
      SET @v_add = CONCAT('alter table ', tableName, ' drop partition ', p_name);
      PREPARE stmt FROM @v_add;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
    END IF;
  END IF;
END
$$

--
-- Create procedure `proc_create_partition_month`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE proc_create_partition_month (IN `tableName` varchar(128) CHARSET utf8,
IN `timeColName` varchar(128) CHARSET utf8)
BEGIN
  #本存储过程会为指定的`tableName`和`timeColName`创建分区表，每天只创建一个，重复调用不会重复创建。
  DECLARE is_partition_exist int;
  DECLARE p_name varchar(16);
  DECLARE p_value varchar(16);
  DECLARE nextDate date;

  #测试是否存在任意分区
  SELECT
    COUNT(partition_name) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName;
  IF is_partition_exist = 0 THEN #如果没有任何分区则，则创建分区函数和一个max分区       
    SET @v_add = CONCAT('ALTER TABLE ', tableName, '  PARTITION BY RANGE (TO_DAYS(', timeColName, '))
( PARTITION max VALUES LESS THAN MAXVALUE ENGINE = INNODB)');

    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;
  END IF;

  #测试是否存在max分区
  SELECT
    COUNT(PARTITION_DESCRIPTION) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName
  AND PARTITION_DESCRIPTION = 'MAXVALUE';
  IF is_partition_exist = 0 THEN #如果没有max分区则创建之       
    SET @v_add = CONCAT('ALTER TABLE ', tableName, ' ADD PARTITION (PARTITION max VALUES LESS THAN (MAXVALUE) ENGINE = INNODB);');
    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;

  END IF;

  SELECT
    DATE_ADD(CURDATE() - DAY(CURDATE()) + 1, INTERVAL 1 MONTH) INTO nextDate
  FROM DUAL;

  SET p_name = CONCAT('p', DATE_FORMAT(nextDate, '%Y%m%d'));
  SET p_value = TO_DAYS(nextDate) + 1;

  #测试是否存在当月分区
  SELECT
    COUNT(PARTITION_DESCRIPTION) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName
  AND PARTITION_DESCRIPTION = p_value;

  IF is_partition_exist = 0 THEN #如果没有当月分区则创建之
    SET @v_add = CONCAT('ALTER table ', tableName
    , ' REORGANIZE PARTITION max INTO(PARTITION '
    , p_name
    , ' values less than ('
    , p_value, '),PARTITION max VALUES LESS THAN(MAXVALUE))');
    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;
  END IF;
  DEALLOCATE PREPARE stmt;
END
$$

--
-- Create procedure `proc_create_partition_day`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE proc_create_partition_day (IN `tableName` varchar(128) CHARSET utf8, IN `timeColName` varchar(128) CHARSET utf8)
BEGIN
  #本存储过程会为指定的`tableName`和`timeColName`创建分区表，每天只创建一个，重复调用不会重复创建。
  DECLARE is_partition_exist int;
  DECLARE p_name varchar(16);
  DECLARE p_value varchar(16);

  #测试是否存在任意分区
  SELECT
    COUNT(partition_name) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName;
  IF is_partition_exist = 0 THEN #如果没有任何分区则，则创建分区函数和一个max分区       
    SET @v_add = CONCAT('ALTER TABLE ', tableName, '  PARTITION BY RANGE (TO_DAYS(', timeColName, '))
( PARTITION max VALUES LESS THAN MAXVALUE ENGINE = INNODB)');

    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;
  END IF;

  #测试是否存在max分区
  SELECT
    COUNT(PARTITION_DESCRIPTION) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName
  AND PARTITION_DESCRIPTION = 'MAXVALUE';
  IF is_partition_exist = 0 THEN #如果没有max分区则创建之       
    SET @v_add = CONCAT('ALTER TABLE ', tableName, ' ADD PARTITION (PARTITION max VALUES LESS THAN (MAXVALUE) ENGINE = INNODB);');
    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;

  END IF;

  SET p_name = CONCAT('p', DATE_FORMAT(CURDATE(), '%Y%m%d'));
  SET p_value = TO_DAYS(CURDATE()) + 1;

  #测试是否存在当日分区
  SELECT
    COUNT(PARTITION_DESCRIPTION) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName
  AND PARTITION_DESCRIPTION = p_value;

  IF is_partition_exist = 0 THEN #如果没有当日分区则创建之
    SET @v_add = CONCAT('ALTER table ', tableName
    , ' REORGANIZE PARTITION max INTO(PARTITION '
    , p_name
    , ' values less than ('
    , p_value, '),PARTITION max VALUES LESS THAN(MAXVALUE))');
    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;
  END IF;
  DEALLOCATE PREPARE stmt;
END
$$

--
-- Create procedure `ManagePartitionsByMonth`
--
CREATE
DEFINER = 'service_user'@'%'
PROCEDURE ManagePartitionsByMonth (IN tableName char(50), IN retainMonths int)
BEGIN
  DECLARE done int DEFAULT 0;
  DECLARE old_partition_name char(50);
  DECLARE partition_date date;
  DECLARE current_months_value int;
  DECLARE highest_months_value int DEFAULT 0;

  -- 定义游标，用于查询指定表的所有分区名
  DECLARE cur CURSOR FOR
  SELECT
    partition_name
  FROM information_schema.partitions
  WHERE table_name = tableName
  AND table_schema = 'radius';

  -- 如果没有更多的分区可以获取，设置done为1
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  -- 获取当前日期的年份和月份值
  SET current_months_value = YEAR(CURRENT_DATE()) * 12 + MONTH(CURRENT_DATE());

  -- 打开游标
  OPEN cur;

-- 循环读取每一个分区名
read_loop:
  LOOP
    FETCH cur INTO old_partition_name;

    -- 当所有分区都被处理时，退出循环
    IF done THEN
      LEAVE read_loop;
    END IF;

    -- 不处理名为'max'的分区
    IF old_partition_name != 'max' THEN
      -- 从分区名中提取日期，并计算其年月值
      SET partition_date = STR_TO_DATE(SUBSTRING(old_partition_name, 2), '%Y%m');
      SET highest_months_value = GREATEST(highest_months_value, YEAR(partition_date) * 12 + MONTH(partition_date));

      -- 如果分区的日期早于要保留的日期或者晚于当前日期，删除分区
      IF highest_months_value < current_months_value - retainMonths
        OR highest_months_value > current_months_value THEN
        SET @sql = CONCAT('ALTER TABLE ', tableName, ' DROP PARTITION ', old_partition_name);

        -- 执行删除分区的SQL
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
      END IF;
    END IF;
  END LOOP;

  -- 关闭游标
  CLOSE cur;

  -- 如果最高月份数值小于当前月份数值，则需要创建一个新分区
  IF highest_months_value < current_months_value THEN
    SET @sql = CONCAT(
    'ALTER TABLE ', tableName, ' REORGANIZE PARTITION max INTO (',
    'PARTITION p', DATE_FORMAT(CURRENT_DATE(), '%Y%m'),
    ' VALUES LESS THAN (', current_months_value + 1, '), ',
    'PARTITION max VALUES LESS THAN MAXVALUE)'
    );

    -- 执行创建新分区的SQL
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
  END IF;

END
$$

--
-- Create procedure `ManagePartitionsByDay`
--
CREATE
DEFINER = 'service_user'@'%'
PROCEDURE ManagePartitionsByDay (IN tableName char(50), IN retainDays int)
BEGIN
  DECLARE done int DEFAULT 0;
  DECLARE old_partition_name char(50);
  DECLARE partition_date date;
  DECLARE current_date_value date;
  DECLARE highest_date_value date DEFAULT '1900-01-01';

  -- 定义游标，用于查询指定表的所有分区名
  DECLARE cur CURSOR FOR
  SELECT
    partition_name
  FROM information_schema.partitions
  WHERE table_name = tableName
  AND table_schema = 'radius';

  -- 如果没有更多的分区可以获取，设置done为1
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  -- 获取当前日期
  SET current_date_value = CURRENT_DATE();

  -- 打开游标
  OPEN cur;

-- 循环读取每一个分区名
read_loop:
  LOOP
    FETCH cur INTO old_partition_name;

    -- 当所有分区都被处理时，退出循环
    IF done THEN
      LEAVE read_loop;
    END IF;

    -- 不处理名为'max'的分区
    IF old_partition_name != 'max' THEN
      -- 从分区名中提取日期
      SET partition_date = STR_TO_DATE(SUBSTRING(old_partition_name, 2), '%Y%m%d');
      SET highest_date_value = GREATEST(highest_date_value, partition_date);

      -- 如果分区的日期早于要保留的日期或者晚于当前日期，删除分区
      IF partition_date < DATE_SUB(current_date_value, INTERVAL retainDays DAY)
        OR partition_date > current_date_value THEN
        SET @sql = CONCAT('ALTER TABLE ', tableName, ' DROP PARTITION ', old_partition_name);

        -- 执行删除分区的SQL
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
      END IF;
    END IF;
  END LOOP;

  -- 关闭游标
  CLOSE cur;

  -- 如果最高的日期值小于当前日期，则需要创建一个新分区
  IF highest_date_value < current_date_value THEN
    SET @sql = CONCAT(
    'ALTER TABLE ', tableName, ' REORGANIZE PARTITION max INTO (',
    'PARTITION p', DATE_FORMAT(CURRENT_DATE(), '%Y%m%d'),
    ' VALUES LESS THAN (TO_DAYS("', DATE_FORMAT(DATE_ADD(current_date_value, INTERVAL 1 DAY), '%Y-%m-%d'), '")), ',
    'PARTITION max VALUES LESS THAN MAXVALUE)'
    );

    -- 执行创建新分区的SQL
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
  END IF;

END
$$

--
-- Create procedure `EnableAllEvents`
--
CREATE
DEFINER = 'service_user'@'%'
PROCEDURE EnableAllEvents ()
BEGIN
  DECLARE done int DEFAULT 0;
  DECLARE eventName char(64);
  DECLARE eventCursor CURSOR FOR
  SELECT
    EVENT_NAME
  FROM INFORMATION_SCHEMA.EVENTS
  WHERE EVENT_SCHEMA = 'radius'
  AND STATUS = 'SLAVESIDE_DISABLED';

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  OPEN eventCursor;

read_loop:
  LOOP
    FETCH eventCursor INTO eventName;

    IF done THEN
      LEAVE read_loop;
    END IF;

    SET @sql = CONCAT('ALTER EVENT ', eventName, ' ENABLE');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

  END LOOP;

  CLOSE eventCursor;
END
$$

--
-- Create event `event_of_month`
--
CREATE 
	DEFINER = 'service_user'@'%'
EVENT event_of_month
	ON SCHEDULE EVERY '1' MONTH
	STARTS '2023-09-20 15:07:32'
	DO 
BEGIN



#创建新分区
#call proc_create_partition_month('offline_user','acctstoptime');


#删除最旧的一个分区
#call proc_drop_partition( 'offline_user',12);




END
$$

ALTER 
	DEFINER = 'service_user'@'%'
EVENT event_of_month
	ENABLE
$$

--
-- Create event `event_of_day`
--
CREATE 
	DEFINER = 'service_user'@'%'
EVENT event_of_day
	ON SCHEDULE EVERY '1' DAY
	STARTS '2023-09-20 15:07:16'
	DO 
BEGIN

 

#call proc_create_partition_day('radpostauth','authdate');

#然后删除最早的一个分区
#call proc_drop_partition( 'radpostauth',7);


END
$$

ALTER 
	DEFINER = 'service_user'@'%'
EVENT event_of_day
	ENABLE
$$

DELIMITER ;

-- 
-- Restore previous SQL mode
-- 
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;

-- 
-- Enable foreign keys
-- 
/*!40014 SET FOREIGN_KEY_CHECKS = @OLD_FOREIGN_KEY_CHECKS */;