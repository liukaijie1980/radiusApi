--
-- Script was generated by Devart dbForge Studio 2022 for MySQL, Version 9.1.21.0
-- Product home page: http://www.devart.com/dbforge/mysql/studio
-- Script date 2024/3/10 6:12:17
-- Server version: 10.6.5
-- Client version: 4.1
--

-- 
-- Disable foreign keys
-- 
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;

-- 
-- Set SQL mode
-- 
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

-- 
-- Set character set the client will use to send SQL statements to the server
--
SET NAMES 'utf8';

--
-- Set default database
--
USE radius;

--
-- Drop event `event_of_month`
--
DROP EVENT IF EXISTS event_of_month;

--
-- Drop procedure `EnableAllEvents`
--
DROP PROCEDURE IF EXISTS EnableAllEvents;

--
-- Drop procedure `proc_create_partition_day`
--
DROP PROCEDURE IF EXISTS proc_create_partition_day;

--
-- Drop procedure `proc_create_partition_month`
--
DROP PROCEDURE IF EXISTS proc_create_partition_month;

--
-- Drop procedure `proc_drop_partition`
--
DROP PROCEDURE IF EXISTS proc_drop_partition;

--
-- Drop table `radcheck`
--
DROP TABLE IF EXISTS radcheck;

--
-- Drop table `radreply`
--
DROP TABLE IF EXISTS radreply;

--
-- Drop event `event_of_day`
--
DROP EVENT IF EXISTS event_of_day;

--
-- Drop procedure `ManagePartitionsByDay`
--
DROP PROCEDURE IF EXISTS ManagePartitionsByDay;

--
-- Drop procedure `ManagePartitionsByMonth`
--
DROP PROCEDURE IF EXISTS ManagePartitionsByMonth;

--
-- Drop procedure `make_node_statistic`
--
DROP PROCEDURE IF EXISTS make_node_statistic;

--
-- Drop procedure `make_report`
--
DROP PROCEDURE IF EXISTS make_report;

--
-- Drop event `event_of_minute`
--
DROP EVENT IF EXISTS event_of_minute;

--
-- Drop trigger `offline_user_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS offline_user_BEFORE_INSERT;

--
-- Drop trigger `offline_user_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS offline_user_BEFORE_UPDATE;

--
-- Drop trigger `online_user_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS online_user_BEFORE_INSERT;

--
-- Drop trigger `online_user_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS online_user_BEFORE_UPDATE;

--
-- Drop table `online_user`
--
DROP TABLE IF EXISTS online_user;

--
-- Drop procedure `database_Prune`
--
DROP PROCEDURE IF EXISTS database_Prune;

--
-- Drop table `offline_user`
--
DROP TABLE IF EXISTS offline_user;

--
-- Drop table `admin`
--
DROP TABLE IF EXISTS admin;

--
-- Drop function `get_coa_secret`
--
DROP FUNCTION IF EXISTS get_coa_secret;

--
-- Drop function `get_reversal`
--
DROP FUNCTION IF EXISTS get_reversal;

--
-- Drop table `nas`
--
DROP TABLE IF EXISTS nas;

--
-- Drop trigger `radpostauth_BEFORE_INSERT`
--
DROP TRIGGER IF EXISTS radpostauth_BEFORE_INSERT;

--
-- Drop trigger `radpostauth_BEFORE_UPDATE`
--
DROP TRIGGER IF EXISTS radpostauth_BEFORE_UPDATE;

--
-- Drop table `radpostauth`
--
DROP TABLE IF EXISTS radpostauth;

--
-- Drop view `view_radreply`
--
DROP VIEW IF EXISTS view_radreply CASCADE;

--
-- Drop function `get_radius_class_attr`
--
DROP FUNCTION IF EXISTS get_radius_class_attr;

--
-- Drop function `get_radius_hw_attr`
--
DROP FUNCTION IF EXISTS get_radius_hw_attr;

--
-- Drop function `get_radius_zte_attr`
--
DROP FUNCTION IF EXISTS get_radius_zte_attr;

--
-- Drop procedure `make_folder_statistic`
--
DROP PROCEDURE IF EXISTS make_folder_statistic;

--
-- Drop table `sidebar_tree`
--
DROP TABLE IF EXISTS sidebar_tree;

--
-- Drop table `node_statistic`
--
DROP TABLE IF EXISTS node_statistic;

--
-- Drop view `view_radcheck`
--
DROP VIEW IF EXISTS view_radcheck CASCADE;

--
-- Drop procedure `generate_account`
--
DROP PROCEDURE IF EXISTS generate_account;

--
-- Drop procedure `test_insert_radcheck`
--
DROP PROCEDURE IF EXISTS test_insert_radcheck;

--
-- Drop trigger `trigger_modify_date`
--
DROP TRIGGER IF EXISTS trigger_modify_date;

--
-- Drop table `account_info`
--
DROP TABLE IF EXISTS account_info;

--
-- Drop table `realm`
--
DROP TABLE IF EXISTS realm;

--
-- Set default database
--
USE radius;

--
-- Create table `realm`
--
CREATE OR REPLACE TABLE realm (
  id varchar(36) NOT NULL,
  realm varchar(45) DEFAULT NULL,
  node_id varchar(36) NOT NULL,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '记录sidebar_tree的node_id和域（realm）的对应关系。';

--
-- Create index `id_UNIQUE` on table `realm`
--
ALTER TABLE realm
ADD UNIQUE INDEX id_UNIQUE (id);

--
-- Create index `realm_UNIQUE` on table `realm`
--
ALTER TABLE realm
ADD UNIQUE INDEX realm_UNIQUE (realm);

--
-- Create table `account_info`
--
CREATE OR REPLACE TABLE account_info (
  id varchar(36) NOT NULL,
  user_name varchar(45) NOT NULL COMMENT '该字段和realm的组合通过唯一约束保证不重复',
  realm varchar(45) NOT NULL DEFAULT '',
  user_password varchar(45) NOT NULL DEFAULT '',
  auth_mode int(10) UNSIGNED ZEROFILL NOT NULL DEFAULT 0000000000,
  is_frozen tinyint(4) NOT NULL DEFAULT 0,
  admin_name varchar(45) NOT NULL DEFAULT '',
  valid_date datetime DEFAULT current_timestamp,
  expire_date datetime DEFAULT NULL,
  modify_date datetime NOT NULL DEFAULT current_timestamp COMMENT '通过update触发器自动维护',
  simual_use_limit int(11) NOT NULL DEFAULT 0,
  byte_remain bigint(20) NOT NULL DEFAULT 0,
  second_remain bigint(20) NOT NULL DEFAULT 0,
  max_session_timeout int(11) NOT NULL DEFAULT 0,
  inbound_car int(11) NOT NULL DEFAULT 0,
  outbound_car int(11) NOT NULL DEFAULT 0,
  qos_profile varchar(45) NOT NULL DEFAULT '' COMMENT 'qos 模板，对应BRAS起的名字',
  update_interval int(11) NOT NULL DEFAULT 0 COMMENT '计费报文间隔',
  UserName varchar(255) GENERATED ALWAYS AS (CONCAT(`user_name`, `realm`)) STORED,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 5461,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '上网用户账号的属性表。方便ui展示和管理，最终要转换到radcheck和radreply的表让radius进程读取才起作用。';

--
-- Create index `user_unique` on table `account_info`
--
ALTER TABLE account_info
ADD UNIQUE INDEX user_unique (user_name, realm);

--
-- Create index `UK_account_info_UserName` on table `account_info`
--
ALTER TABLE account_info
ADD UNIQUE INDEX UK_account_info_UserName (UserName);

DELIMITER $$

--
-- Create trigger `trigger_modify_date`
--
CREATE OR REPLACE
DEFINER = 'service_user'@'%'
TRIGGER trigger_modify_date
BEFORE UPDATE
ON account_info
FOR EACH ROW
BEGIN


  SET new.modify_date = CURRENT_TIMESTAMP;

END
$$

--
-- Create procedure `test_insert_radcheck`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
PROCEDURE test_insert_radcheck (IN p_from int, IN p_to int)
BEGIN
  DECLARE current_val int DEFAULT p_from;
loopname:
  LOOP
    INSERT INTO radius.account_info (id, user_name, realm, user_password, auth_mode, is_frozen, admin_name, valid_date, expire_date, modify_date, simual_use_limit, byte_remain, second_remain, max_session_timeout, inbound_car, outbound_car, qos_profile, update_interval)
      VALUES (CONCAT('test_', current_val), current_val, '@kdlk', '00000000', 0, 0, 'admin', '2023-08-01 14:13:29', NULL, '2023-08-01 14:13:29', 1, 0, 0, 0, 256000, 512000, '', 900);
    SET current_val = current_val + 1;
    IF current_val > p_to THEN
      LEAVE loopname;
    END IF;
  END LOOP loopname;
END
$$

--
-- Create procedure `generate_account`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
PROCEDURE generate_account (IN p_from int, IN p_to int)
BEGIN
  DECLARE current_val int DEFAULT p_from;
loopname:
  LOOP
    INSERT INTO radius.account_info (id, user_name, realm, user_password, auth_mode, is_frozen, admin_name, valid_date, expire_date, modify_date, simual_use_limit, byte_remain, second_remain, max_session_timeout, inbound_car, outbound_car, qos_profile, update_interval)
      VALUES (CONCAT('test_', current_val), current_val, '@kdlk', '00000000', 0, 0, 'admin', '2023-08-01 14:13:29', NULL, '2023-08-01 14:13:29', 1, 0, 0, 0, 256000, 512000, '', 900);
    SET current_val = current_val + 1;
    IF current_val > p_to THEN
      LEAVE loopname;
    END IF;
  END LOOP loopname;
END
$$

DELIMITER ;

--
-- Create view `view_radcheck`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
VIEW view_radcheck
AS
SELECT
  '1100' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Cleartext-Password' AS `Attribute`,
  `account_info`.`user_password` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE `account_info`.`is_frozen` = 0
AND (`account_info`.`valid_date` IS NOT NULL
AND `account_info`.`valid_date` < CURRENT_TIMESTAMP()
OR `account_info`.`valid_date` IS NULL)
AND (`account_info`.`expire_date` IS NOT NULL
AND `account_info`.`expire_date` > CURRENT_TIMESTAMP()
OR `account_info`.`expire_date` IS NULL)
AND `account_info`.`byte_remain` >= 0
AND `account_info`.`second_remain` >= 0
UNION ALL
SELECT
  '1101' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Simultaneous-Use' AS `Attribute`,
  `account_info`.`simual_use_limit` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE `account_info`.`simual_use_limit` > 0;

--
-- Create table `node_statistic`
--
CREATE OR REPLACE TABLE node_statistic (
  node_id varchar(36) NOT NULL,
  total_accounts int(10) UNSIGNED DEFAULT 0,
  online_accounts int(10) UNSIGNED DEFAULT 0,
  online_terminals int(10) UNSIGNED DEFAULT 0,
  PRIMARY KEY (node_id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 5461,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `node_id_UNIQUE` on table `node_statistic`
--
ALTER TABLE node_statistic
ADD UNIQUE INDEX node_id_UNIQUE (node_id);

--
-- Create table `sidebar_tree`
--
CREATE OR REPLACE TABLE sidebar_tree (
  id varchar(36) NOT NULL,
  label varchar(45) DEFAULT NULL,
  pid varchar(36) DEFAULT NULL,
  type tinyint(4) DEFAULT NULL,
  owner varchar(45) DEFAULT NULL,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 1365,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '管理后台的左侧树控件节点集合';

--
-- Create index `id_UNIQUE` on table `sidebar_tree`
--
ALTER TABLE sidebar_tree
ADD UNIQUE INDEX id_UNIQUE (id);

DELIMITER $$

--
-- Create procedure `make_folder_statistic`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
PROCEDURE make_folder_statistic (IN `_node_id` varchar(36) CHARSET utf8, IN `i` int, IN `j` int, IN `k` int)
BEGIN
  DECLARE _pid varchar(36) DEFAULT "";


  SET @@max_sp_recursion_depth = 10;


  IF EXISTS (SELECT
        *
      FROM sidebar_tree
      WHERE id = _node_id) THEN


    SELECT
      pid INTO _pid
    FROM sidebar_tree
    WHERE id = _node_id;



    IF EXISTS (SELECT
          *
        FROM sidebar_tree
        WHERE id = _pid) THEN


      INSERT INTO node_statistic (node_id, total_accounts, online_accounts, online_terminals)
        VALUE (_pid, total_accounts + i, online_accounts + j, online_terminals + k)
      ON DUPLICATE KEY UPDATE total_accounts = total_accounts + i, online_accounts = online_accounts + j, online_terminals = online_terminals + k;


      CALL make_folder_statistic(_pid, i, j, k);
    END IF;
  END IF;

END
$$

--
-- Create function `get_radius_zte_attr`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
FUNCTION get_radius_zte_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN
  DECLARE ustr,
          dstr varchar(100);
  IF (dlimit = 0
    OR ulimit = 0) THEN
    RETURN NULL;
  END IF;
  SET ustr := HEX(ulimit);
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN
    SET ustr := 'FFFFFFFF';
  END IF;
  SET ustr := LPAD(ustr, 8, '0');
  SET dstr := HEX(dlimit);
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN
    SET dstr := 'FFFFFFFF';
  END IF;
  SET dstr := LPAD(dstr, 8, '0');
  RETURN CONCAT('0x00000F3E5906', dstr, '5306', ustr);

END
$$

--
-- Create function `get_radius_hw_attr`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
FUNCTION get_radius_hw_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN

  DECLARE ustr,
          dstr varchar(100);
  IF (dlimit = 0
    OR ulimit = 0) THEN
    RETURN NULL;
  END IF;

  SET ustr := HEX(ulimit * 1024);
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN
    SET ustr := 'FFFFFFFF';
  END IF;
  SET ustr := LPAD(ustr, 8, '0');

  SET dstr := HEX(dlimit * 1024);
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN
    SET dstr := 'FFFFFFFF';
  END IF;
  SET dstr := LPAD(dstr, 8, '0');

  RETURN CONCAT('0x000007DB0206', dstr, '0306', dstr, '0506', ustr, '0606', ustr);
END
$$

--
-- Create function `get_radius_class_attr`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
FUNCTION get_radius_class_attr (ulimit int, dlimit int)
RETURNS varchar(100) CHARSET utf8mb4
DETERMINISTIC
BEGIN


  DECLARE ustr,
          dstr varchar(100);

  SELECT
    CONCAT(ulimit * 1024, '') INTO ustr
  FROM dual;
  IF (LENGTH(ustr) > 8
    OR ulimit = 0) THEN

    RETURN NULL;
  END IF;
  SET ustr := LPAD(ustr, 8, '0');

  SELECT
    CONCAT(dlimit * 1024, '') INTO dstr
  FROM dual;
  IF (LENGTH(dstr) > 8
    OR dlimit = 0) THEN

    RETURN NULL;
  END IF;

  SET dstr := LPAD(dstr, 8, '0');


  RETURN CONCAT(ustr, ustr, dstr, dstr);
END
$$

DELIMITER ;

--
-- Create view `view_radreply`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
VIEW view_radreply
AS
SELECT
  '1000' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Session-Timeout' AS `Attribute`,
  `account_info`.`max_session_timeout` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE `account_info`.`max_session_timeout` <> 0
UNION ALL
SELECT
  '1001' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Acct-Interim-Interval' AS `Attribute`,
  `account_info`.`update_interval` AS `Value`,
  ':=' AS `op`
FROM `account_info`
WHERE `account_info`.`update_interval` <> 0
UNION ALL
SELECT
  '1002' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Class' AS `Attribute`,
  `GET_RADIUS_CLASS_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_CLASS_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1003' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_HW_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_HW_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1004' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_ZTE_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_ZTE_ATTR`(`account_info`.`inbound_car`, `account_info`.`outbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1005' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Class' AS `Attribute`,
  `GET_RADIUS_CLASS_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_CLASS_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1006' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_HW_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_HW_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) IS NOT NULL
UNION ALL
SELECT
  '1007' AS `id`,
  `account_info`.`UserName` AS `UserName`,
  'Attr-26' AS `Attribute`,
  `GET_RADIUS_ZTE_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) AS `VALUE`,
  ':=' AS `op`
FROM `account_info`
WHERE `GET_RADIUS_ZTE_ATTR`(`account_info`.`outbound_car`, `account_info`.`inbound_car`) IS NOT NULL;

--
-- Create table `radpostauth`
--
CREATE OR REPLACE TABLE radpostauth (
  id bigint(20) NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  pass varchar(64) NOT NULL DEFAULT '',
  reply varchar(32) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  authdate datetime NOT NULL DEFAULT current_timestamp ON UPDATE CURRENT_TIMESTAMP,
  _class varchar(64) DEFAULT NULL,
  PRIMARY KEY (id, authdate)
)
ENGINE = INNODB,
AUTO_INCREMENT = 148539350,
AVG_ROW_LENGTH = 57344,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '认证日志表，按天分区，保留7天'
PARTITION BY RANGE (TO_DAYS(`authdate`))
(
PARTITION p20240302 VALUES LESS THAN (739313),
PARTITION p20240303 VALUES LESS THAN (739314),
PARTITION p20240304 VALUES LESS THAN (739315),
PARTITION p20240305 VALUES LESS THAN (739316),
PARTITION p20240306 VALUES LESS THAN (739317),
PARTITION p20240307 VALUES LESS THAN (739318),
PARTITION p20240308 VALUES LESS THAN (739319),
PARTITION p20240309 VALUES LESS THAN (739320),
PARTITION max VALUES LESS THAN MAXVALUE
);

--
-- Create index `username` on table `radpostauth`
--
ALTER TABLE radpostauth
ADD INDEX username (username);

DELIMITER $$

--
-- Create trigger `radpostauth_BEFORE_UPDATE`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
TRIGGER radpostauth_BEFORE_UPDATE
BEFORE UPDATE
ON radpostauth
FOR EACH ROW
BEGIN

  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;
END
$$

--
-- Create trigger `radpostauth_BEFORE_INSERT`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
TRIGGER radpostauth_BEFORE_INSERT
BEFORE INSERT
ON radpostauth
FOR EACH ROW
BEGIN

  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;
END
$$

DELIMITER ;

--
-- Create table `nas`
--
CREATE OR REPLACE TABLE nas (
  id int(11) NOT NULL AUTO_INCREMENT,
  nasname varchar(128) NOT NULL DEFAULT '*',
  shortname varchar(32) DEFAULT 'any',
  type varchar(30) DEFAULT 'other',
  ports int(11) DEFAULT 0,
  secret varchar(60) NOT NULL DEFAULT '',
  coa varchar(60) NOT NULL,
  reversal tinyint(1) NOT NULL DEFAULT 0,
  server varchar(64) DEFAULT NULL,
  community varchar(50) DEFAULT NULL,
  description varchar(200) DEFAULT 'RADIUS Client',
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 106,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `nasname` on table `nas`
--
ALTER TABLE nas
ADD INDEX nasname (nasname);

DELIMITER $$

--
-- Create function `get_reversal`
--
CREATE OR REPLACE
DEFINER = 'service_user'@'%'
FUNCTION get_reversal (nasip varchar(255))
RETURNS tinyint(1)
BEGIN

  DECLARE done int DEFAULT 0;
  DECLARE ip varchar(255);
  DECLARE net varchar(255);
  DECLARE mask int;
  DECLARE mask_offset int;
  DECLARE value_reversal tinyint(1);
  DECLARE is_reversal tinyint(1);

  DECLARE cur CURSOR FOR
  SELECT
    nasname,
    reversal
  FROM nas;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  CREATE TEMPORARY TABLE TempResults (
    max_mask int,
    reversal tinyint(1)
  );

  OPEN cur;
read_loop:
  LOOP
    FETCH cur INTO ip, value_reversal;
    IF done THEN
      LEAVE read_loop;
    END IF;

    IF ip = '*' THEN
      INSERT INTO TempResults (max_mask, reversal)
        VALUES (0, value_reversal);

    ELSEIF ip = nasip THEN
      INSERT INTO TempResults (max_mask, reversal)
        VALUES (32, value_reversal);

    ELSEIF INSTR(ip, '/') > 0 THEN
      SET net = SUBSTRING_INDEX (ip, '/', 1);
      SET mask = CAST(SUBSTRING_INDEX (ip, '/', -1) AS UNSIGNED);
      SET mask_offset = 32 - mask;
      IF (INET_ATON(nasip) >> mask_offset << mask_offset) = (INET_ATON(net) >> mask_offset << mask_offset) THEN

        INSERT INTO TempResults (max_mask, reversal)
          VALUES (mask, value_reversal);
      END IF;



    END IF;


  END LOOP;
  CLOSE cur;

  SELECT
    reversal INTO is_reversal
  FROM TempResults
  ORDER BY max_mask DESC LIMIT 1;

  DROP TEMPORARY TABLE IF EXISTS TempResults;
  RETURN is_reversal;


END
$$

--
-- Create function `get_coa_secret`
--
CREATE OR REPLACE
DEFINER = 'service_user'@'%'
FUNCTION get_coa_secret (nasip varchar(255))
RETURNS varchar(255) CHARSET utf8mb4
BEGIN

  DECLARE done int DEFAULT 0;
  DECLARE ip varchar(255);
  DECLARE net varchar(255);
  DECLARE mask int;
  DECLARE mask_offset int;

  DECLARE coa_secret varchar(255);

  DECLARE cur CURSOR FOR
  SELECT
    nasname,
    coa
  FROM nas;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  CREATE TEMPORARY TABLE TempResults (
    max_mask int,
    coa varchar(255)
  );

  OPEN cur;
read_loop:
  LOOP
    FETCH cur INTO ip, coa_secret;
    IF done THEN
      LEAVE read_loop;
    END IF;

    IF ip = '*' THEN
      INSERT INTO TempResults (max_mask, coa)
        VALUES (0, coa_secret);

    ELSEIF ip = nasip THEN
      INSERT INTO TempResults (max_mask, coa)
        VALUES (32, coa_secret);

    ELSEIF INSTR(ip, '/') > 0 THEN
      SET net = SUBSTRING_INDEX (ip, '/', 1);
      SET mask = CAST(SUBSTRING_INDEX (ip, '/', -1) AS UNSIGNED);
      SET mask_offset = 32 - mask;
      IF (INET_ATON(nasip) >> mask_offset << mask_offset) = (INET_ATON(net) >> mask_offset << mask_offset) THEN

        INSERT INTO TempResults (max_mask, coa)
          VALUES (mask, coa_secret);
      END IF;



    END IF;


  END LOOP;
  CLOSE cur;

  SELECT
    coa INTO coa_secret
  FROM TempResults
  ORDER BY max_mask DESC LIMIT 1;

  DROP TEMPORARY TABLE IF EXISTS TempResults;
  RETURN coa_secret;


END
$$

DELIMITER ;

--
-- Create table `admin`
--
CREATE OR REPLACE TABLE admin (
  name varchar(45) NOT NULL,
  password varchar(45) DEFAULT NULL,
  nodeid varchar(36) DEFAULT NULL,
  role varchar(45) DEFAULT NULL,
  phone varchar(45) DEFAULT NULL,
  email varchar(45) DEFAULT NULL,
  PRIMARY KEY (name)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 1820,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = '节点管理员列表';

--
-- Create index `name_UNIQUE` on table `admin`
--
ALTER TABLE admin
ADD UNIQUE INDEX name_UNIQUE (name);

--
-- Create table `offline_user`
--
CREATE OR REPLACE TABLE offline_user (
  radacctid bigint(20) NOT NULL AUTO_INCREMENT,
  acctsessionid varchar(64) NOT NULL DEFAULT '',
  acctuniqueid varchar(32) NOT NULL DEFAULT '',
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  nasipaddress varchar(15) NOT NULL DEFAULT '',
  nasportid varchar(120) DEFAULT NULL,
  nasporttype varchar(32) DEFAULT NULL,
  acctstarttime datetime DEFAULT NULL,
  acctupdatetime datetime DEFAULT NULL,
  acctstoptime datetime NOT NULL DEFAULT current_timestamp,
  acctinterval int(11) DEFAULT NULL,
  acctsessiontime int(11) DEFAULT NULL,
  acctauthentic varchar(32) DEFAULT NULL,
  connectinfo_start varchar(128) DEFAULT NULL,
  connectinfo_stop varchar(128) DEFAULT NULL,
  acctinputoctets bigint(20) DEFAULT NULL,
  acctoutputoctets bigint(20) DEFAULT NULL,
  calledstationid varchar(50) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  acctterminatecause varchar(32) NOT NULL DEFAULT '',
  servicetype varchar(32) DEFAULT NULL,
  framedprotocol varchar(32) DEFAULT NULL,
  framedipaddress varchar(15) NOT NULL DEFAULT '',
  framedipv6address varchar(45) NOT NULL DEFAULT '',
  framedipv6prefix varchar(45) NOT NULL DEFAULT '',
  framedinterfaceid varchar(44) NOT NULL DEFAULT '',
  delegatedipv6prefix varchar(45) NOT NULL DEFAULT '',
  _class varchar(64) DEFAULT NULL,
  kickme int(11) NOT NULL DEFAULT 0,
  PRIMARY KEY (radacctid, acctstoptime)
)
ENGINE = INNODB,
AUTO_INCREMENT = 3646000,
AVG_ROW_LENGTH = 2184,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci
PARTITION BY RANGE (TO_DAYS(`acctstoptime`))
(
PARTITION p202309 VALUES LESS THAN (24286),
PARTITION p202310 VALUES LESS THAN (24287),
PARTITION p202311 VALUES LESS THAN (24288),
PARTITION p202312 VALUES LESS THAN (24289),
PARTITION p202401 VALUES LESS THAN (24290),
PARTITION p202402 VALUES LESS THAN (24291),
PARTITION p202403 VALUES LESS THAN (24292),
PARTITION max VALUES LESS THAN MAXVALUE
);

--
-- Create index `acctuniqueid` on table `offline_user`
--
ALTER TABLE offline_user
ADD UNIQUE INDEX acctuniqueid (acctuniqueid, acctstoptime);

--
-- Create index `acctsessionid` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctsessionid (acctsessionid);

--
-- Create index `acctstarttime` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctstarttime (acctstarttime);

--
-- Create index `acctstoptime` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX acctstoptime (acctstoptime);

--
-- Create index `callingstationid` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX callingstationid (callingstationid);

--
-- Create index `framedipaddress` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX framedipaddress (framedipaddress);

--
-- Create index `nasipaddress` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX nasipaddress (nasipaddress);

--
-- Create index `realm` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX realm (realm);

--
-- Create index `IDX_offline_user_username` on table `offline_user`
--
ALTER TABLE offline_user
ADD INDEX IDX_offline_user_username (username);

DELIMITER $$

--
-- Create procedure `database_Prune`
--
CREATE OR REPLACE
DEFINER = 'service_user'@'%'
PROCEDURE database_Prune ()
BEGIN

  DELETE
    FROM realm
  WHERE node_id NOT IN (SELECT
        id
      FROM sidebar_tree);


  DELETE
    FROM account_info
  WHERE realm NOT IN (SELECT
        realm
      FROM realm);

  DELETE
    FROM admin
  WHERE nodeid NOT IN (SELECT
        id
      FROM sidebar_tree);

  DELETE
    FROM offline_user
  WHERE realm NOT IN (SELECT
        realm
      FROM realm);


  DELETE
    FROM radpostauth
  WHERE realm NOT IN (SELECT
        realm
      FROM realm);
END
$$

DELIMITER ;

--
-- Create table `online_user`
--
CREATE OR REPLACE TABLE online_user (
  radacctid bigint(20) NOT NULL AUTO_INCREMENT,
  acctsessionid varchar(64) NOT NULL DEFAULT '',
  acctuniqueid varchar(32) NOT NULL DEFAULT '',
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  nasidentifier varchar(80) NOT NULL DEFAULT '',
  nasipaddress varchar(15) NOT NULL DEFAULT '',
  nasportid varchar(120) DEFAULT NULL,
  nasporttype varchar(32) DEFAULT NULL,
  acctstarttime datetime DEFAULT NULL,
  acctupdatetime datetime NOT NULL DEFAULT current_timestamp,
  acctstoptime datetime DEFAULT NULL,
  acctinterval int(11) DEFAULT NULL,
  acctsessiontime int(11) DEFAULT NULL,
  acctauthentic varchar(32) DEFAULT NULL,
  connectinfo_start varchar(128) DEFAULT NULL,
  connectinfo_stop varchar(128) DEFAULT NULL,
  acctinputoctets bigint(20) DEFAULT NULL,
  acctoutputoctets bigint(20) DEFAULT NULL,
  calledstationid varchar(50) NOT NULL DEFAULT '',
  callingstationid varchar(50) NOT NULL DEFAULT '',
  acctterminatecause varchar(32) NOT NULL DEFAULT '',
  servicetype varchar(32) DEFAULT NULL,
  framedprotocol varchar(32) DEFAULT NULL,
  framedipaddress varchar(15) NOT NULL DEFAULT '',
  framedipv6address varchar(45) NOT NULL DEFAULT '',
  framedipv6prefix varchar(45) NOT NULL DEFAULT '',
  framedinterfaceid varchar(44) NOT NULL DEFAULT '',
  delegatedipv6prefix varchar(45) NOT NULL DEFAULT '',
  _class varchar(64) DEFAULT NULL,
  kickme int(11) NOT NULL DEFAULT 0,
  PRIMARY KEY (radacctid)
)
ENGINE = INNODB,
AUTO_INCREMENT = 60810605,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `acctuniqueid` on table `online_user`
--
ALTER TABLE online_user
ADD UNIQUE INDEX acctuniqueid (acctuniqueid);

--
-- Create index `acctsessionid` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctsessionid (acctsessionid);

--
-- Create index `acctstarttime` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctstarttime (acctstarttime);

--
-- Create index `acctstoptime` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX acctstoptime (acctstoptime);

--
-- Create index `callingstationid` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX callingstationid (callingstationid);

--
-- Create index `framedipaddress` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX framedipaddress (framedipaddress);

--
-- Create index `framedipv6address` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX framedipv6address (framedipv6address);

--
-- Create index `nasipaddress` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX nasipaddress (nasipaddress);

--
-- Create index `username` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX username (username);

--
-- Create index `IDX_online_user_realm` on table `online_user`
--
ALTER TABLE online_user
ADD INDEX IDX_online_user_realm (realm);

DELIMITER $$

--
-- Create trigger `online_user_BEFORE_UPDATE`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
TRIGGER online_user_BEFORE_UPDATE
BEFORE UPDATE
ON online_user
FOR EACH ROW
BEGIN

  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;



  SET new.acctupdatetime = NOW();


END
$$

--
-- Create trigger `online_user_BEFORE_INSERT`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
TRIGGER online_user_BEFORE_INSERT
BEFORE INSERT
ON online_user
FOR EACH ROW
BEGIN

  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;


  SET new.acctstarttime = NOW();
  SET new.acctupdatetime = NOW();

END
$$

--
-- Create trigger `offline_user_BEFORE_UPDATE`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
TRIGGER offline_user_BEFORE_UPDATE
BEFORE UPDATE
ON offline_user
FOR EACH ROW
BEGIN

  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;


  SET new.acctstoptime = NOW();

  IF new.acctsessiontime IS NOT NULL
    AND new.acctsessiontime != 0 THEN
    SET new.acctstarttime = DATE_SUB(new.acctstoptime, INTERVAL new.acctsessiontime SECOND);
  ELSE

    SET @starttime := new.acctstoptime;
    SELECT
      acctstarttime INTO @starttime
    FROM online_user
    WHERE acctsessionid = new.acctsessionid LIMIT 1;
    SET new.acctstarttime := @starttime;

    SET new.acctsessiontime = ABS(TIMESTAMPDIFF(SECOND, new.acctstarttime, new.acctstoptime));
  END IF;


  UPDATE account_info
  SET second_remain = (second_remain - new.acctsessiontime)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND second_remain > 0;


  UPDATE account_info
  SET byte_remain = (byte_remain - new.acctinputoctets - new.acctoutputoctets)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND byte_remain > 0;


  DELETE
    FROM online_user
  WHERE acctsessionid = new.acctsessionid
    AND username = new.username
    AND realm = new.realm;
END
$$

--
-- Create trigger `offline_user_BEFORE_INSERT`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
TRIGGER offline_user_BEFORE_INSERT
BEFORE INSERT
ON offline_user
FOR EACH ROW
BEGIN

  IF INSTR(new.username, "@") > 0
    AND INSTR(new.realm, "@") = 0 THEN
    SET new.realm = SUBSTR(new.username, INSTR(new.username, "@"));
    SET new.username = LEFT(new.username, INSTR(new.username, "@") - 1);
  END IF;

  SET new.acctstoptime = NOW();

  IF new.acctsessiontime IS NOT NULL
    AND new.acctsessiontime != 0 THEN
    SET new.acctstarttime = DATE_SUB(new.acctstoptime, INTERVAL new.acctsessiontime SECOND);
  ELSE

    SET @starttime := new.acctstoptime;
    SELECT
      acctstarttime INTO @starttime
    FROM online_user
    WHERE acctsessionid = new.acctsessionid LIMIT 1;
    SET new.acctstarttime := @starttime;

    SET new.acctsessiontime = ABS(TIMESTAMPDIFF(SECOND, new.acctstarttime, new.acctstoptime));
  END IF;


  UPDATE account_info
  SET second_remain = (second_remain - new.acctsessiontime)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND second_remain > 0;


  UPDATE account_info
  SET byte_remain = (byte_remain - new.acctinputoctets - new.acctoutputoctets)
  WHERE user_name = new.username
  AND realm = NEW.realm
  AND byte_remain > 0;


  DELETE
    FROM online_user
  WHERE acctsessionid = new.acctsessionid
    AND username = new.username
    AND realm = new.realm;

END
$$

--
-- Create event `event_of_minute`
--
CREATE OR REPLACE 
	DEFINER = 'service_user'@'%'
EVENT event_of_minute
	ON SCHEDULE EVERY '1' MINUTE
	STARTS '2023-10-06 23:50:49'
	DO 
BEGIN

UPDATE  radius.online_user SET acctstoptime=NOW() WHERE ABS(TIMESTAMPDIFF(SECOND, NOW(), acctupdatetime))>3600 AND acctstoptime IS NULL ;



CREATE  TEMPORARY  TABLE `temp_user` (
  `radacctid` bigint NOT NULL AUTO_INCREMENT,
  `acctsessionid` varchar(64) NOT NULL DEFAULT '',
  `acctuniqueid` varchar(32) NOT NULL DEFAULT '',
  `username` varchar(45) NOT NULL DEFAULT '',
  `realm` varchar(45) NOT NULL DEFAULT '',
  `nasidentifier` varchar(80) NOT NULL DEFAULT '',
  `nasipaddress` varchar(15) NOT NULL DEFAULT '',
  `nasportid` varchar(120) DEFAULT NULL,
  `nasporttype` varchar(32) DEFAULT NULL,
  `acctstarttime` datetime DEFAULT NULL,
  `acctupdatetime` datetime DEFAULT NULL,
  `acctstoptime` datetime DEFAULT NULL,
  `acctinterval` int DEFAULT NULL,
  `acctsessiontime` int DEFAULT NULL,
  `acctauthentic` varchar(32) DEFAULT NULL,
  `connectinfo_start` varchar(128) DEFAULT NULL,
  `connectinfo_stop` varchar(128) DEFAULT NULL,
  `acctinputoctets` bigint DEFAULT NULL,
  `acctoutputoctets` bigint DEFAULT NULL,
  `calledstationid` varchar(50) NOT NULL DEFAULT '',
  `callingstationid` varchar(50) NOT NULL DEFAULT '',
  `acctterminatecause` varchar(32) NOT NULL DEFAULT '',
  `servicetype` varchar(32) DEFAULT NULL,
  `framedprotocol` varchar(32) DEFAULT NULL,
  `framedipaddress` varchar(15) NOT NULL DEFAULT '',
  `framedipv6address` varchar(45) NOT NULL DEFAULT '',
  `framedipv6prefix` varchar(45) NOT NULL DEFAULT '',
  `framedinterfaceid` varchar(44) NOT NULL DEFAULT '',
  `delegatedipv6prefix` varchar(45) NOT NULL DEFAULT '',
  `_class` varchar(64) DEFAULT NULL,
   kickme int NOT NULL DEFAULT 0,
  PRIMARY KEY (`radacctid`),
  UNIQUE KEY `acctuniqueid` (`acctuniqueid`)

) ENGINE=memory  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;


INSERT INTO temp_user
SELECT * FROM online_user WHERE acctstoptime IS NOT NULL ;


INSERT INTO offline_user SELECT * FROM temp_user  ;
drop table temp_user;


DELETE FROM realm  WHERE node_id NOT IN (SELECT id FROM sidebar_tree  );

DELETE FROM admin WHERE nodeid NOT IN (SELECT id FROM sidebar_tree  );
COMMIT;



END
$$

ALTER 
	DEFINER = 'service_user'@'%'
EVENT event_of_minute
	ENABLE
$$

--
-- Create procedure `make_report`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
PROCEDURE make_report ()
BEGIN
  DECLARE acct1 int;
  DECLARE acct2 int;
  DECLARE acct int;
  DECLARE auth int;




  SELECT
    COUNT(*) INTO acct1
  FROM offline_user
  WHERE acctstoptime > NOW() - INTERVAL 10 MINUTE;
  SELECT
    COUNT(*) INTO acct2
  FROM online_user
  WHERE acctupdatetime > NOW() - INTERVAL 10 MINUTE;
  SET acct = acct1 + acct2;


  SELECT
    COUNT(*) INTO auth
  FROM radpostauth
  WHERE authdate > NOW() - INTERVAL 10 MINUTE;

  SELECT
    acct AS acct,
    auth AS auth;





END
$$

--
-- Create procedure `make_node_statistic`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
PROCEDURE make_node_statistic ()
BEGIN



  DECLARE i integer DEFAULT 0;
  DECLARE j integer DEFAULT 0;
  DECLARE k integer DEFAULT 0;


  DECLARE v_finished integer DEFAULT 0;


  DECLARE _node_id varchar(36) DEFAULT "";

  DECLARE _pid varchar(36) DEFAULT "";


  DECLARE _realm varchar(45) DEFAULT "";


  DECLARE leaf_cursor CURSOR FOR
  SELECT
    id
  FROM sidebar_tree
  WHERE type = 0;


  DECLARE realm_cursor CURSOR FOR
  SELECT
    realm
  FROM realm
  WHERE node_id = _node_id;


  DECLARE leaf_statistic_cursor CURSOR FOR
  SELECT
    node_id
  FROM node_statistic
    INNER JOIN sidebar_tree
      ON node_statistic.node_id = sidebar_tree.id
  WHERE type = 0;



  DECLARE CONTINUE HANDLER
  FOR NOT FOUND SET v_finished = 1;

  DELETE
    FROM node_statistic;
  OPEN leaf_cursor;

get_id:
  LOOP
    FETCH leaf_cursor INTO _node_id;
    IF v_finished = 1 THEN
      LEAVE get_id;
    END IF;


    OPEN realm_cursor;

  get_realm:
    LOOP
      FETCH realm_cursor INTO _realm;
      IF v_finished = 1 THEN
        LEAVE get_realm;
      END IF;


      SELECT
        COUNT(*) INTO i
      FROM account_info
      WHERE realm = _realm;
      SELECT
        COUNT(DISTINCT (username)) INTO j
      FROM online_user
      WHERE realm = _realm
      AND acctstoptime IS NULL;
      SELECT
        COUNT(DISTINCT (callingstationid)) INTO k
      FROM online_user
      WHERE realm = _realm
      AND acctstoptime IS NULL;


      INSERT INTO node_statistic (node_id, total_accounts, online_accounts, online_terminals)
        VALUE (_node_id, total_accounts + i, online_accounts + j, online_terminals + k)
      ON DUPLICATE KEY UPDATE total_accounts = total_accounts + i, online_accounts = online_accounts + j, online_terminals = online_terminals + k;
    END LOOP get_realm;
    CLOSE realm_cursor;

    SET v_finished = 0;
  END LOOP get_id;
  CLOSE leaf_cursor;
  SET v_finished = 0;




  OPEN leaf_statistic_cursor;
get_leaf_id:
  LOOP
    FETCH leaf_statistic_cursor INTO _node_id;
    IF v_finished = 1 THEN
      LEAVE get_leaf_id;
    END IF;
    SELECT
      total_accounts INTO i
    FROM node_statistic
    WHERE node_id = _node_id;
    SELECT
      online_accounts INTO j
    FROM node_statistic
    WHERE node_id = _node_id;
    SELECT
      online_terminals INTO k
    FROM node_statistic
    WHERE node_id = _node_id;


    CALL make_folder_statistic(_node_id, i, j, k);


  END LOOP get_leaf_id;
  CLOSE leaf_statistic_cursor;




END
$$

--
-- Create procedure `ManagePartitionsByMonth`
--
CREATE OR REPLACE
DEFINER = 'service_user'@'%'
PROCEDURE ManagePartitionsByMonth (IN tableName char(50), IN retainMonths int)
BEGIN
  DECLARE done int DEFAULT 0;
  DECLARE old_partition_name char(50);
  DECLARE partition_date date;
  DECLARE current_months_value int;
  DECLARE highest_months_value int DEFAULT 0;


  DECLARE cur CURSOR FOR
  SELECT
    partition_name
  FROM information_schema.partitions
  WHERE table_name = tableName
  AND table_schema = 'radius';


  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;


  SET current_months_value = YEAR(CURRENT_DATE()) * 12 + MONTH(CURRENT_DATE());


  OPEN cur;


read_loop:
  LOOP
    FETCH cur INTO old_partition_name;


    IF done THEN
      LEAVE read_loop;
    END IF;


    IF old_partition_name != 'max' THEN

      SET partition_date = STR_TO_DATE(SUBSTRING(old_partition_name, 2), '%Y%m');
      SET highest_months_value = GREATEST(highest_months_value, YEAR(partition_date) * 12 + MONTH(partition_date));


      IF highest_months_value < current_months_value - retainMonths
        OR highest_months_value > current_months_value THEN
        SET @sql = CONCAT('ALTER TABLE ', tableName, ' DROP PARTITION ', old_partition_name);


        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
      END IF;
    END IF;
  END LOOP;


  CLOSE cur;


  IF highest_months_value < current_months_value THEN
    SET @sql = CONCAT(
    'ALTER TABLE ', tableName, ' REORGANIZE PARTITION max INTO (',
    'PARTITION p', DATE_FORMAT(CURRENT_DATE(), '%Y%m'),
    ' VALUES LESS THAN (', current_months_value + 1, '), ',
    'PARTITION max VALUES LESS THAN MAXVALUE)'
    );


    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
  END IF;

END
$$

--
-- Create procedure `ManagePartitionsByDay`
--
CREATE OR REPLACE
DEFINER = 'service_user'@'%'
PROCEDURE ManagePartitionsByDay (IN tableName char(50), IN retainDays int)
BEGIN
  DECLARE done int DEFAULT 0;
  DECLARE old_partition_name char(50);
  DECLARE partition_date date;
  DECLARE current_date_value date;
  DECLARE highest_date_value date DEFAULT '1900-01-01';


  DECLARE cur CURSOR FOR
  SELECT
    partition_name
  FROM information_schema.partitions
  WHERE table_name = tableName
  AND table_schema = 'radius';


  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;


  SET current_date_value = CURRENT_DATE();


  OPEN cur;


read_loop:
  LOOP
    FETCH cur INTO old_partition_name;


    IF done THEN
      LEAVE read_loop;
    END IF;


    IF old_partition_name != 'max' THEN

      SET partition_date = STR_TO_DATE(SUBSTRING(old_partition_name, 2), '%Y%m%d');
      SET highest_date_value = GREATEST(highest_date_value, partition_date);


      IF partition_date < DATE_SUB(current_date_value, INTERVAL retainDays DAY)
        OR partition_date > current_date_value THEN
        SET @sql = CONCAT('ALTER TABLE ', tableName, ' DROP PARTITION ', old_partition_name);


        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
      END IF;
    END IF;
  END LOOP;


  CLOSE cur;


  IF highest_date_value < current_date_value THEN
    SET @sql = CONCAT(
    'ALTER TABLE ', tableName, ' REORGANIZE PARTITION max INTO (',
    'PARTITION p', DATE_FORMAT(CURRENT_DATE(), '%Y%m%d'),
    ' VALUES LESS THAN (TO_DAYS("', DATE_FORMAT(DATE_ADD(current_date_value, INTERVAL 1 DAY), '%Y-%m-%d'), '")), ',
    'PARTITION max VALUES LESS THAN MAXVALUE)'
    );


    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
  END IF;

END
$$

--
-- Create event `event_of_day`
--
CREATE OR REPLACE 
	DEFINER = 'root'@'%'
EVENT event_of_day
	ON SCHEDULE EVERY '1' DAY
	STARTS '2023-09-20 15:07:16'
	DO 
BEGIN

CALL ManagePartitionsByDay('radpostauth',7);
CALL ManagePartitionsByMonth('offline_user',12);

DELETE FROM account_info WHERE realm NOT IN (SELECT realm FROM realm );

UPDATE   online_user  set kickme=1  WHERE  CONCAT(username,realm)  NOT IN  (  SELECT username FROM   view_radcheck WHERE Attribute='Cleartext-Password');

END
$$

ALTER 
	DEFINER = 'root'@'%'
EVENT event_of_day
	ENABLE
$$

DELIMITER ;

--
-- Create table `radreply`
--
CREATE OR REPLACE TABLE radreply (
  id int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  attribute varchar(64) NOT NULL DEFAULT '',
  op char(2) NOT NULL DEFAULT ':=',
  value varchar(253) NOT NULL DEFAULT '',
  account_id varchar(36) NOT NULL,
  is_frozen tinyint(4) NOT NULL DEFAULT 0,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 3,
AVG_ROW_LENGTH = 8192,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `username` on table `radreply`
--
ALTER TABLE radreply
ADD INDEX username (username (32));

--
-- Create table `radcheck`
--
CREATE OR REPLACE TABLE radcheck (
  id int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  username varchar(45) NOT NULL DEFAULT '',
  realm varchar(45) NOT NULL DEFAULT '',
  attribute varchar(64) NOT NULL DEFAULT '',
  op char(2) NOT NULL DEFAULT ':=',
  value varchar(253) NOT NULL DEFAULT '',
  account_id varchar(36) NOT NULL,
  is_frozen tinyint(4) NOT NULL DEFAULT 0,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 24,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci;

--
-- Create index `ix_rcheck_username` on table `radcheck`
--
ALTER TABLE radcheck
ADD INDEX ix_rcheck_username (username);

DELIMITER $$

--
-- Create procedure `proc_drop_partition`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
PROCEDURE proc_drop_partition (IN `tableName` varchar(128) CHARSET utf8, IN `reservePartition` int)
BEGIN
  DECLARE p_id int;
  DECLARE p_name varchar(16);

  SELECT
    COUNT(partition_name) INTO p_id
  FROM INFORMATION_SCHEMA.PARTITIONS
  WHERE TABLE_NAME = tableName;

  IF p_id > reservePartition THEN

    SELECT
      PARTITION_NAME INTO p_name
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_NAME = tableName
    ORDER BY partition_ordinal_position ASC LIMIT 1;

    IF p_name IS NOT NULL THEN
      SET @v_add = CONCAT('alter table ', tableName, ' drop partition ', p_name);
      PREPARE stmt FROM @v_add;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
    END IF;
  END IF;
END
$$

--
-- Create procedure `proc_create_partition_month`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
PROCEDURE proc_create_partition_month (IN `tableName` varchar(128) CHARSET utf8,
IN `timeColName` varchar(128) CHARSET utf8)
BEGIN

  DECLARE is_partition_exist int;
  DECLARE p_name varchar(16);
  DECLARE p_value varchar(16);
  DECLARE nextDate date;


  SELECT
    COUNT(partition_name) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName;
  IF is_partition_exist = 0 THEN
    SET @v_add = CONCAT('ALTER TABLE ', tableName, '  PARTITION BY RANGE (TO_DAYS(', timeColName, '))
( PARTITION max VALUES LESS THAN MAXVALUE ENGINE = INNODB)');

    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;
  END IF;


  SELECT
    COUNT(PARTITION_DESCRIPTION) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName
  AND PARTITION_DESCRIPTION = 'MAXVALUE';
  IF is_partition_exist = 0 THEN
    SET @v_add = CONCAT('ALTER TABLE ', tableName, ' ADD PARTITION (PARTITION max VALUES LESS THAN (MAXVALUE) ENGINE = INNODB);');
    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;

  END IF;

  SELECT
    DATE_ADD(CURDATE() - DAY(CURDATE()) + 1, INTERVAL 1 MONTH) INTO nextDate
  FROM DUAL;

  SET p_name = CONCAT('p', DATE_FORMAT(nextDate, '%Y%m%d'));
  SET p_value = TO_DAYS(nextDate) + 1;


  SELECT
    COUNT(PARTITION_DESCRIPTION) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName
  AND PARTITION_DESCRIPTION = p_value;

  IF is_partition_exist = 0 THEN
    SET @v_add = CONCAT('ALTER table ', tableName
    , ' REORGANIZE PARTITION max INTO(PARTITION '
    , p_name
    , ' values less than ('
    , p_value, '),PARTITION max VALUES LESS THAN(MAXVALUE))');
    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;
  END IF;
  DEALLOCATE PREPARE stmt;
END
$$

--
-- Create procedure `proc_create_partition_day`
--
CREATE OR REPLACE
DEFINER = 'root'@'%'
PROCEDURE proc_create_partition_day (IN `tableName` varchar(128) CHARSET utf8, IN `timeColName` varchar(128) CHARSET utf8)
BEGIN

  DECLARE is_partition_exist int;
  DECLARE p_name varchar(16);
  DECLARE p_value varchar(16);


  SELECT
    COUNT(partition_name) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName;
  IF is_partition_exist = 0 THEN
    SET @v_add = CONCAT('ALTER TABLE ', tableName, '  PARTITION BY RANGE (TO_DAYS(', timeColName, '))
( PARTITION max VALUES LESS THAN MAXVALUE ENGINE = INNODB)');

    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;
  END IF;


  SELECT
    COUNT(PARTITION_DESCRIPTION) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName
  AND PARTITION_DESCRIPTION = 'MAXVALUE';
  IF is_partition_exist = 0 THEN
    SET @v_add = CONCAT('ALTER TABLE ', tableName, ' ADD PARTITION (PARTITION max VALUES LESS THAN (MAXVALUE) ENGINE = INNODB);');
    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;

  END IF;

  SET p_name = CONCAT('p', DATE_FORMAT(CURDATE(), '%Y%m%d'));
  SET p_value = TO_DAYS(CURDATE()) + 1;


  SELECT
    COUNT(PARTITION_DESCRIPTION) INTO is_partition_exist
  FROM INFORMATION_SCHEMA.partitions
  WHERE TABLE_NAME = tableName
  AND PARTITION_DESCRIPTION = p_value;

  IF is_partition_exist = 0 THEN
    SET @v_add = CONCAT('ALTER table ', tableName
    , ' REORGANIZE PARTITION max INTO(PARTITION '
    , p_name
    , ' values less than ('
    , p_value, '),PARTITION max VALUES LESS THAN(MAXVALUE))');
    SELECT
      @v_add;
    PREPARE stmt FROM @v_add;
    EXECUTE stmt;
  END IF;
  DEALLOCATE PREPARE stmt;
END
$$

--
-- Create procedure `EnableAllEvents`
--
CREATE OR REPLACE
DEFINER = 'service_user'@'%'
PROCEDURE EnableAllEvents ()
BEGIN

  DECLARE done int DEFAULT 0;
  DECLARE eventName char(64);
  DECLARE eventCursor CURSOR FOR
  SELECT
    EVENT_NAME
  FROM INFORMATION_SCHEMA.EVENTS
  WHERE EVENT_SCHEMA = 'radius'
  AND STATUS = 'SLAVESIDE_DISABLED';

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  SET GLOBAL read_only = 0;
  SET GLOBAL event_scheduler = ON;
  OPEN eventCursor;

read_loop:
  LOOP
    FETCH eventCursor INTO eventName;

    IF done THEN
      LEAVE read_loop;
    END IF;

    SET @sql = CONCAT('ALTER EVENT ', eventName, ' ENABLE');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

  END LOOP;

  CLOSE eventCursor;
END
$$

--
-- Create event `event_of_month`
--
CREATE OR REPLACE 
	DEFINER = 'service_user'@'%'
EVENT event_of_month
	ON SCHEDULE EVERY '1' MONTH
	STARTS '2023-09-20 15:07:32'
	DO 
BEGIN













END
$$

ALTER 
	DEFINER = 'service_user'@'%'
EVENT event_of_month
	ENABLE
$$

DELIMITER ;

-- 
-- Restore previous SQL mode
-- 
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;

-- 
-- Enable foreign keys
-- 
/*!40014 SET FOREIGN_KEY_CHECKS = @OLD_FOREIGN_KEY_CHECKS */;